// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: beeswax/openrtb/openrtb.proto

package openrtb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// OpenRTB Native 7.4: Common image asset element types of native advertising at
// the time of writing this spec. This list is non-exhaustive and intended to be
// extended by the buyers and sellers as the format evolves.
type NativeRequest_Asset_Image_ImageAssetType int32

const (
	// * Icon image.
	NativeRequest_Asset_Image_ICON NativeRequest_Asset_Image_ImageAssetType = 1
	// * Logo image for the brand/app.
	NativeRequest_Asset_Image_LOGO NativeRequest_Asset_Image_ImageAssetType = 2
	// * Large image preview for the ad.
	NativeRequest_Asset_Image_MAIN NativeRequest_Asset_Image_ImageAssetType = 3
)

var NativeRequest_Asset_Image_ImageAssetType_name = map[int32]string{
	1: "ICON",
	2: "LOGO",
	3: "MAIN",
}
var NativeRequest_Asset_Image_ImageAssetType_value = map[string]int32{
	"ICON": 1,
	"LOGO": 2,
	"MAIN": 3,
}

func (x NativeRequest_Asset_Image_ImageAssetType) Enum() *NativeRequest_Asset_Image_ImageAssetType {
	p := new(NativeRequest_Asset_Image_ImageAssetType)
	*p = x
	return p
}
func (x NativeRequest_Asset_Image_ImageAssetType) String() string {
	return proto.EnumName(NativeRequest_Asset_Image_ImageAssetType_name, int32(x))
}
func (x *NativeRequest_Asset_Image_ImageAssetType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NativeRequest_Asset_Image_ImageAssetType_value, data, "NativeRequest_Asset_Image_ImageAssetType")
	if err != nil {
		return err
	}
	*x = NativeRequest_Asset_Image_ImageAssetType(value)
	return nil
}
func (NativeRequest_Asset_Image_ImageAssetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{2, 0, 1, 0}
}

// *
// OpenRTB Native 7.3: Common asset element types of native advertising.
// This list is non-exhaustive and intended to be extended by the buyers and sellers
// as the format evolves. An implementing exchange may not support all asset variants
// or introduce new ones unique to that system.
type NativeRequest_Asset_Data_DataAssetType int32

const (
	// * Sponsored By message where response should contain the brand name of the sponsor.
	NativeRequest_Asset_Data_SPONSORED NativeRequest_Asset_Data_DataAssetType = 1
	// * Descriptive text associated with the product or service being advertised.
	NativeRequest_Asset_Data_DESC NativeRequest_Asset_Data_DataAssetType = 2
	// *
	// Rating of the product being offered to the user.
	// For example an app's rating in an app store from 0-5.
	NativeRequest_Asset_Data_RATING NativeRequest_Asset_Data_DataAssetType = 3
	// * Number of social ratings or "likes" of the product being offered to the user.
	NativeRequest_Asset_Data_LIKES NativeRequest_Asset_Data_DataAssetType = 4
	// * Number downloads/installs of this product.
	NativeRequest_Asset_Data_DOWNLOADS NativeRequest_Asset_Data_DataAssetType = 5
	// *
	// Price for product / app / in-app purchase.
	// Value should include currency symbol in localised format.
	NativeRequest_Asset_Data_PRICE NativeRequest_Asset_Data_DataAssetType = 6
	// *
	// Sale price that can be used together with price to indicate a discounted price
	// compared to a regular price. Value should include currency symbol in localised format.
	NativeRequest_Asset_Data_SALEPRICE NativeRequest_Asset_Data_DataAssetType = 7
	// * Phone number.
	NativeRequest_Asset_Data_PHONE NativeRequest_Asset_Data_DataAssetType = 8
	// * Address.
	NativeRequest_Asset_Data_ADDRESS NativeRequest_Asset_Data_DataAssetType = 9
	// * Additional descriptive text associated with the product or service being advertised.
	NativeRequest_Asset_Data_DESC2 NativeRequest_Asset_Data_DataAssetType = 10
	// * Display URL for the text ad.
	NativeRequest_Asset_Data_DISPLAYURL NativeRequest_Asset_Data_DataAssetType = 11
	// * Text describing a "call to action" button for the destination URL.
	NativeRequest_Asset_Data_CTATEXT NativeRequest_Asset_Data_DataAssetType = 12
	// STORE bit for ADX NativeAdTemplate
	NativeRequest_Asset_Data_STORE NativeRequest_Asset_Data_DataAssetType = 500
)

var NativeRequest_Asset_Data_DataAssetType_name = map[int32]string{
	1:   "SPONSORED",
	2:   "DESC",
	3:   "RATING",
	4:   "LIKES",
	5:   "DOWNLOADS",
	6:   "PRICE",
	7:   "SALEPRICE",
	8:   "PHONE",
	9:   "ADDRESS",
	10:  "DESC2",
	11:  "DISPLAYURL",
	12:  "CTATEXT",
	500: "STORE",
}
var NativeRequest_Asset_Data_DataAssetType_value = map[string]int32{
	"SPONSORED":  1,
	"DESC":       2,
	"RATING":     3,
	"LIKES":      4,
	"DOWNLOADS":  5,
	"PRICE":      6,
	"SALEPRICE":  7,
	"PHONE":      8,
	"ADDRESS":    9,
	"DESC2":      10,
	"DISPLAYURL": 11,
	"CTATEXT":    12,
	"STORE":      500,
}

func (x NativeRequest_Asset_Data_DataAssetType) Enum() *NativeRequest_Asset_Data_DataAssetType {
	p := new(NativeRequest_Asset_Data_DataAssetType)
	*p = x
	return p
}
func (x NativeRequest_Asset_Data_DataAssetType) String() string {
	return proto.EnumName(NativeRequest_Asset_Data_DataAssetType_name, int32(x))
}
func (x *NativeRequest_Asset_Data_DataAssetType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NativeRequest_Asset_Data_DataAssetType_value, data, "NativeRequest_Asset_Data_DataAssetType")
	if err != nil {
		return err
	}
	*x = NativeRequest_Asset_Data_DataAssetType(value)
	return nil
}
func (NativeRequest_Asset_Data_DataAssetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{2, 0, 2, 0}
}

//
// OpenRTB 3.3.1: The top-level bid request object.
type BidRequest struct {
	//
	// Unique ID of the bid request, provided by the exchange.
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	//
	// Multiple impression auctions may be specified in a single bid request.
	// At least one impression is required for a valid bid request.
	Imp []*BidRequest_Impression `protobuf:"bytes,2,rep,name=imp" json:"imp,omitempty"`
	//
	// Information pertaining to a website.
	Site *BidRequest_Site `protobuf:"bytes,3,opt,name=site" json:"site,omitempty"`
	//
	// Information pertaining to a mobile application.
	App *BidRequest_App `protobuf:"bytes,4,opt,name=app" json:"app,omitempty"`
	//
	// Information pertaining to the device.
	Device *BidRequest_Device `protobuf:"bytes,5,opt,name=device" json:"device,omitempty"`
	//
	// Information known or derived about the human user of the device.
	User *BidRequest_User `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// *
	// Indicator of test mode in which auctions are not billable,
	// where 0 = live mode, 1 = test mode.
	Test *bool `protobuf:"varint,15,opt,name=test,def=0" json:"test,omitempty"`
	//
	// Auction Type. If “1”, then first price auction. If “2”, then second price
	// auction.
	// Additional auction types can be defined as per the exchange’s business
	// rules.
	// Exchange specific rules should be numbered over 500.
	At *int32 `protobuf:"varint,7,opt,name=at,def=2" json:"at,omitempty"`
	//
	// Maximum amount of time in milliseconds to submit a bid (e.g., 120 means the
	// bidder has 120ms to submit a bid before the auction is complete). If this
	// value never changes across an exchange, then the exchange can supply this
	// information offline.
	Tmax *int32 `protobuf:"varint,8,opt,name=tmax" json:"tmax,omitempty"`
	//
	// Array of buyer seats allowed to bid on this auction. Seats are an optional
	// feature of exchange. For example, [“4”,”34”,”82”,”A45”] indicates that only
	// advertisers using these exchange seats are allowed to bid on the
	// impressions in this auction.
	Wseat []string `protobuf:"bytes,9,rep,name=wseat" json:"wseat,omitempty"`
	//
	// Flag to indicate whether Exchange can verify that all impressions offered
	// represent all of the impressions available in context (e.g., all
	// impressions available on the web page; all impressions available for a
	// video [pre, mid and postroll spots], etc.) to support road-blocking. A true
	// value should only be passed if the exchange is aware of all impressions in
	// context for the publisher. NO means the exchange cannot verify, and YES
	// means that all impressions represent all impressions available.
	Allimps *Flag `protobuf:"varint,10,opt,name=allimps,enum=openrtb.Flag,def=0" json:"allimps,omitempty"`
	//
	// Array of allowed currencies for bids on this bid request using ISO-4217 alphabetic codes.
	// If only one currency is used by the exchange, this parameter is not required.
	Cur []string `protobuf:"bytes,11,rep,name=cur" json:"cur,omitempty"`
	//
	// Blocked Advertiser Categories. Note that there is no existing categorization / taxonomy of
	// advertiser industries. However, as a substitute exchanges may decide to use IAB categories
	// as an approximation.
	Bcat []string `protobuf:"bytes,12,rep,name=bcat" json:"bcat,omitempty"`
	//
	// Array of strings of blocked top-level domains of advertisers.
	// For example, {“company1.com”, “company2.com”}.
	Badv []string `protobuf:"bytes,13,rep,name=badv" json:"badv,omitempty"`
	//
	// Container for any legal, governmental or industry regulations in force for the request.
	Regs *BidRequest_Regulations `protobuf:"bytes,14,opt,name=regs" json:"regs,omitempty"`
	//
	// A Source object (Section 3.2.2) that provides data about the
	// inventory source and which entity makes the final decision.
	Source           *BidRequest_Source    `protobuf:"bytes,19,opt,name=source" json:"source,omitempty"`
	Ext              *BidRequestExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *BidRequest) Reset()                    { *m = BidRequest{} }
func (m *BidRequest) String() string            { return proto.CompactTextString(m) }
func (*BidRequest) ProtoMessage()               {}
func (*BidRequest) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0} }

const Default_BidRequest_Test bool = false
const Default_BidRequest_At int32 = 2
const Default_BidRequest_Allimps Flag = Flag_NO

func (m *BidRequest) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest) GetImp() []*BidRequest_Impression {
	if m != nil {
		return m.Imp
	}
	return nil
}

func (m *BidRequest) GetSite() *BidRequest_Site {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *BidRequest) GetApp() *BidRequest_App {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *BidRequest) GetDevice() *BidRequest_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *BidRequest) GetUser() *BidRequest_User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *BidRequest) GetTest() bool {
	if m != nil && m.Test != nil {
		return *m.Test
	}
	return Default_BidRequest_Test
}

func (m *BidRequest) GetAt() int32 {
	if m != nil && m.At != nil {
		return *m.At
	}
	return Default_BidRequest_At
}

func (m *BidRequest) GetTmax() int32 {
	if m != nil && m.Tmax != nil {
		return *m.Tmax
	}
	return 0
}

func (m *BidRequest) GetWseat() []string {
	if m != nil {
		return m.Wseat
	}
	return nil
}

func (m *BidRequest) GetAllimps() Flag {
	if m != nil && m.Allimps != nil {
		return *m.Allimps
	}
	return Default_BidRequest_Allimps
}

func (m *BidRequest) GetCur() []string {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *BidRequest) GetBcat() []string {
	if m != nil {
		return m.Bcat
	}
	return nil
}

func (m *BidRequest) GetBadv() []string {
	if m != nil {
		return m.Badv
	}
	return nil
}

func (m *BidRequest) GetRegs() *BidRequest_Regulations {
	if m != nil {
		return m.Regs
	}
	return nil
}

func (m *BidRequest) GetSource() *BidRequest_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *BidRequest) GetExt() *BidRequestExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 2.5: This object describes the nature and behavior of the entity
// that is the source of the bid request upstream from the exchange.
// The primary purpose of this object is to define post-auction or upstream
// decisioning when the exchange itself does not control the final decision.
// A common example of this is header bidding, but it can also apply to
// upstream server entities such as another RTB exchange, a mediation
// platform, or an ad server combines direct campaigns with 3rd party
// demand in decisioning.
type BidRequest_Source struct {
	//
	// Entity responsible for the final impression sale decision,
	// where 0 = exchange, 1 = upstream source
	// RECOMMENDED by the OpenRTB specification.
	Fd *bool `protobuf:"varint,1,opt,name=fd" json:"fd,omitempty"`
	//
	// Transaction ID that must be common across all participants in
	// this bid request (e.g., potentially multiple exchanges).
	// RECOMMENDED by the OpenRTB specification.
	Tid *string `protobuf:"bytes,2,opt,name=tid" json:"tid,omitempty"`
	//
	// Payment ID chain string containing embedded syntax
	// described in the TAG Payment ID Protocol v1.0.
	// RECOMMENDED by the OpenRTB specification.
	Pchain                       *string `protobuf:"bytes,3,opt,name=pchain" json:"pchain,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *BidRequest_Source) Reset()                    { *m = BidRequest_Source{} }
func (m *BidRequest_Source) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Source) ProtoMessage()               {}
func (*BidRequest_Source) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 0} }

var extRange_BidRequest_Source = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*BidRequest_Source) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_BidRequest_Source
}

func (m *BidRequest_Source) GetFd() bool {
	if m != nil && m.Fd != nil {
		return *m.Fd
	}
	return false
}

func (m *BidRequest_Source) GetTid() string {
	if m != nil && m.Tid != nil {
		return *m.Tid
	}
	return ""
}

func (m *BidRequest_Source) GetPchain() string {
	if m != nil && m.Pchain != nil {
		return *m.Pchain
	}
	return ""
}

//
// OpenRTB 3.3.2: describes the ad position or impression being auctioned.
// A single bid request can include multiple “imp” objects, a use case for which might be an
// exchange that supports selling all ad positions on a given page as a bundle.
// Each “imp” object has a required ID so that bids can reference them individually.
// An exchange can also conduct private auctions by restricting involvement to specific
// subsets of seats within bidders.
type BidRequest_Impression struct {
	//
	// A unique identifier for this impression within the context of the bid request
	// (typically, value starts with 1, and increments up to n for n impressions).
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	//
	// Banner object. Either a banner or video object (or both if the impression could be either)
	// must be included in an impression object.
	Banner *BidRequest_Impression_Banner `protobuf:"bytes,2,opt,name=banner" json:"banner,omitempty"`
	//
	// Video object. Either a banner or video object (or both if the impression could be either)
	// must be included in an impression object.
	Video *BidRequest_Impression_Video `protobuf:"bytes,3,opt,name=video" json:"video,omitempty"`
	// *
	// A Native object (Section 3.2.5); required if this impression is
	// offered as a native ad opportunity.
	Native *BidRequest_Impression_Native `protobuf:"bytes,13,opt,name=native" json:"native,omitempty"`
	//
	// Name of ad mediation partner, SDK technology, or native player responsible for rendering
	// ad (typically video or mobile). Used by some ad servers to customize ad code by partner.
	Displaymanager *string `protobuf:"bytes,4,opt,name=displaymanager" json:"displaymanager,omitempty"`
	//
	// Version of ad mediation partner, SDK technology, or native player responsible for rendering
	// ad (typically video or mobile). Used by some ad servers to customize ad code by partner.
	Displaymanagerver *string `protobuf:"bytes,5,opt,name=displaymanagerver" json:"displaymanagerver,omitempty"`
	//
	// YES if the ad is interstitial or full screen; else NO.
	Instl *Flag `protobuf:"varint,6,opt,name=instl,enum=openrtb.Flag,def=0" json:"instl,omitempty"`
	//
	// Identifier for specific ad placement or ad tag that was used to initiate the auction.
	// This can be useful for debugging of any issues, or for optimization by the buyer.
	Tagid *string `protobuf:"bytes,7,opt,name=tagid" json:"tagid,omitempty"`
	//
	// Bid floor for this impression (in CPM of bidfloorcur).
	Bidfloor *float64 `protobuf:"fixed64,8,opt,name=bidfloor,def=0" json:"bidfloor,omitempty"`
	//
	// If bid floor is specified and multiple currencies supported per bid request,
	// then currency should be specified here using ISO-4217 alphabetic codes.
	// Note, this may be different from bid currency returned by bidder,
	// if this is allowed on an exchange.
	Bidfloorcur *string `protobuf:"bytes,9,opt,name=bidfloorcur,def=USD" json:"bidfloorcur,omitempty"`
	//
	// Array of names for supported iframe busters. Exchange specific.
	Iframebuster []string `protobuf:"bytes,10,rep,name=iframebuster" json:"iframebuster,omitempty"`
	//
	// Contains any Deals eligible for this Impression.
	Pmp *BidRequest_Impression_PMP `protobuf:"bytes,11,opt,name=pmp" json:"pmp,omitempty"`
	//
	// A flag to indicate if the impression requires secure HTTPS creative
	// assets and markup.
	// Value of 1 indicates that the impression requires secure creatives.
	// If the value is 0 or not set, then the impression allows non-secure
	// HTTP creatives.
	Secure *int32 `protobuf:"varint,12,opt,name=secure" json:"secure,omitempty"`
	//
	// Advisory as to the number of seconds that may elapse
	// between the auction and the actual impression.
	Exp              *int32                `protobuf:"varint,14,opt,name=exp" json:"exp,omitempty"`
	Ext              *ImpressionExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *BidRequest_Impression) Reset()                    { *m = BidRequest_Impression{} }
func (m *BidRequest_Impression) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Impression) ProtoMessage()               {}
func (*BidRequest_Impression) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 1} }

const Default_BidRequest_Impression_Instl Flag = Flag_NO
const Default_BidRequest_Impression_Bidfloor float64 = 0
const Default_BidRequest_Impression_Bidfloorcur string = "USD"

func (m *BidRequest_Impression) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Impression) GetBanner() *BidRequest_Impression_Banner {
	if m != nil {
		return m.Banner
	}
	return nil
}

func (m *BidRequest_Impression) GetVideo() *BidRequest_Impression_Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *BidRequest_Impression) GetNative() *BidRequest_Impression_Native {
	if m != nil {
		return m.Native
	}
	return nil
}

func (m *BidRequest_Impression) GetDisplaymanager() string {
	if m != nil && m.Displaymanager != nil {
		return *m.Displaymanager
	}
	return ""
}

func (m *BidRequest_Impression) GetDisplaymanagerver() string {
	if m != nil && m.Displaymanagerver != nil {
		return *m.Displaymanagerver
	}
	return ""
}

func (m *BidRequest_Impression) GetInstl() Flag {
	if m != nil && m.Instl != nil {
		return *m.Instl
	}
	return Default_BidRequest_Impression_Instl
}

func (m *BidRequest_Impression) GetTagid() string {
	if m != nil && m.Tagid != nil {
		return *m.Tagid
	}
	return ""
}

func (m *BidRequest_Impression) GetBidfloor() float64 {
	if m != nil && m.Bidfloor != nil {
		return *m.Bidfloor
	}
	return Default_BidRequest_Impression_Bidfloor
}

func (m *BidRequest_Impression) GetBidfloorcur() string {
	if m != nil && m.Bidfloorcur != nil {
		return *m.Bidfloorcur
	}
	return Default_BidRequest_Impression_Bidfloorcur
}

func (m *BidRequest_Impression) GetIframebuster() []string {
	if m != nil {
		return m.Iframebuster
	}
	return nil
}

func (m *BidRequest_Impression) GetPmp() *BidRequest_Impression_PMP {
	if m != nil {
		return m.Pmp
	}
	return nil
}

func (m *BidRequest_Impression) GetSecure() int32 {
	if m != nil && m.Secure != nil {
		return *m.Secure
	}
	return 0
}

func (m *BidRequest_Impression) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *BidRequest_Impression) GetExt() *ImpressionExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.3: A banner object typically describes an ad impressions opportunity for banner,
// rich media or in-banner video inventory.
type BidRequest_Impression_Banner struct {
	//
	// Width of the impression in pixels. Since some ad types are not restricted by size
	// this field is not required, but it’s highly recommended.
	W *int32 `protobuf:"varint,1,opt,name=w" json:"w,omitempty"`
	//
	// Height of the impression in pixels. Since some ad types are not restricted by size
	// this field is not required, but it’s highly recommended.
	H *int32 `protobuf:"varint,2,opt,name=h" json:"h,omitempty"`
	// *
	// Maximum width of the impression in pixels. If included, it indicates that a range
	// of sizes is allowed with this maximum width and "w" is taken as recommended.
	// If not included, then "w" should be considered an exact requirement.
	Wmax *int32 `protobuf:"varint,11,opt,name=wmax" json:"wmax,omitempty"`
	// *
	// Maximum height of the impression in pixels. If included, it indicates that a range
	// of sizes is allowed with this maximum height and "h" is taken as recommended.
	// If not included, then "h" should be considered an exact requirement.
	Hmax *int32 `protobuf:"varint,12,opt,name=hmax" json:"hmax,omitempty"`
	// *
	// Minimum width of the impression in pixels. If included, it indicates that a range
	// of sizes is allowed with this minimum width and "w" is taken as recommended.
	// If not included, then "w" should be considered an exact requirement.
	Wmin *int32 `protobuf:"varint,13,opt,name=wmin" json:"wmin,omitempty"`
	// *
	// Minumum height of the impression in pixels. If included, it indicates
	// that a range of sizes is allowed with this minimum height and "h" is
	// taken as recommended.
	// If not included, then "h" should be considered an exact requirement.
	Hmin *int32 `protobuf:"varint,14,opt,name=hmin" json:"hmin,omitempty"`
	//
	// Unique identifier for this banner object. Useful for tracking multiple banner objects
	// (e.g., in companion banner array). Usually starts with 1, increasing with each object.
	// Combination of impression id X banner id should be unique.
	Id *string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	//
	// The position of the ad as a relative measure of visibility or
	// prominence.
	Pos *Enums_BidRequest_Impression_AdPosition `protobuf:"varint,4,opt,name=pos,enum=openrtb.Enums_BidRequest_Impression_AdPosition,def=0" json:"pos,omitempty"`
	//
	// Blocked creative types. If blank, assume all types are allowed.
	Btype []Enums_BidRequest_Impression_Banner_AdType `protobuf:"varint,5,rep,name=btype,enum=openrtb.Enums_BidRequest_Impression_Banner_AdType" json:"btype,omitempty"`
	//
	// Blocked creative attributes. If blank assume all types are allowed.
	Battr []CreativeAttribute `protobuf:"varint,6,rep,name=battr,enum=openrtb.CreativeAttribute" json:"battr,omitempty"`
	//
	// Whitelist of content MIME types supported. Popular MIME types include,
	// but are not limited to “image/jpg”, “image/gif” and “application/x-shockwave-flash”.
	Mimes []string `protobuf:"bytes,7,rep,name=mimes" json:"mimes,omitempty"`
	//
	// Specify if the banner is delivered in the top frame (YES) or in an iframe (NO).
	Topframe *Flag `protobuf:"varint,8,opt,name=topframe,enum=openrtb.Flag,def=0" json:"topframe,omitempty"`
	//
	// Specify properties for an expandable ad.
	Expdir []Enums_BidRequest_Impression_Banner_ExpandableDirection `protobuf:"varint,9,rep,name=expdir,enum=openrtb.Enums_BidRequest_Impression_Banner_ExpandableDirection" json:"expdir,omitempty"`
	//
	// List of supported API frameworks for this banner. If an API is not explicitly listed
	// it is assumed not to be supported.
	Api              []Enums_BidRequest_Impression_ApiFramework `protobuf:"varint,10,rep,name=api,enum=openrtb.Enums_BidRequest_Impression_ApiFramework" json:"api,omitempty"`
	Ext              *BannerExtensions                          `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                                     `json:"-"`
}

func (m *BidRequest_Impression_Banner) Reset()         { *m = BidRequest_Impression_Banner{} }
func (m *BidRequest_Impression_Banner) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Impression_Banner) ProtoMessage()    {}
func (*BidRequest_Impression_Banner) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 1, 0}
}

const Default_BidRequest_Impression_Banner_Pos Enums_BidRequest_Impression_AdPosition = Enums_BidRequest_Impression_POSITION_UNKNOWN
const Default_BidRequest_Impression_Banner_Topframe Flag = Flag_NO

func (m *BidRequest_Impression_Banner) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetWmax() int32 {
	if m != nil && m.Wmax != nil {
		return *m.Wmax
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetHmax() int32 {
	if m != nil && m.Hmax != nil {
		return *m.Hmax
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetWmin() int32 {
	if m != nil && m.Wmin != nil {
		return *m.Wmin
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetHmin() int32 {
	if m != nil && m.Hmin != nil {
		return *m.Hmin
	}
	return 0
}

func (m *BidRequest_Impression_Banner) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Impression_Banner) GetPos() Enums_BidRequest_Impression_AdPosition {
	if m != nil && m.Pos != nil {
		return *m.Pos
	}
	return Default_BidRequest_Impression_Banner_Pos
}

func (m *BidRequest_Impression_Banner) GetBtype() []Enums_BidRequest_Impression_Banner_AdType {
	if m != nil {
		return m.Btype
	}
	return nil
}

func (m *BidRequest_Impression_Banner) GetBattr() []CreativeAttribute {
	if m != nil {
		return m.Battr
	}
	return nil
}

func (m *BidRequest_Impression_Banner) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

func (m *BidRequest_Impression_Banner) GetTopframe() Flag {
	if m != nil && m.Topframe != nil {
		return *m.Topframe
	}
	return Default_BidRequest_Impression_Banner_Topframe
}

func (m *BidRequest_Impression_Banner) GetExpdir() []Enums_BidRequest_Impression_Banner_ExpandableDirection {
	if m != nil {
		return m.Expdir
	}
	return nil
}

func (m *BidRequest_Impression_Banner) GetApi() []Enums_BidRequest_Impression_ApiFramework {
	if m != nil {
		return m.Api
	}
	return nil
}

func (m *BidRequest_Impression_Banner) GetExt() *BannerExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.4: A video object typically describes an ad opportunity for in-stream video
// inventory (including linear pre-roll, mid-roll and post-roll, and non-linear overlays).
// Please note, in-banner video is typically represented by the banner object.
type BidRequest_Impression_Video struct {
	//
	// Whitelist of content MIME types supported. Popular MIME types include,
	// but are not limited to “image/jpg”, “image/gif” and “application/x-shockwave-flash”.
	Mimes []string `protobuf:"bytes,1,rep,name=mimes" json:"mimes,omitempty"`
	//
	// Indicates whether the ad impression is linear or non-linear.
	Linearity *Enums_BidRequest_Impression_Video_Linearity `protobuf:"varint,2,opt,name=linearity,enum=openrtb.Enums_BidRequest_Impression_Video_Linearity,def=1" json:"linearity,omitempty"`
	//
	// Minimum video ad duration in seconds.
	Minduration *int32 `protobuf:"varint,3,opt,name=minduration" json:"minduration,omitempty"`
	//
	// Maximum video ad duration in seconds.
	Maxduration *int32 `protobuf:"varint,4,opt,name=maxduration" json:"maxduration,omitempty"`
	//
	// Video bid response protocols.
	Protocols []Enums_BidRequest_Impression_Video_Protocol `protobuf:"varint,5,rep,name=protocols,enum=openrtb.Enums_BidRequest_Impression_Video_Protocol" json:"protocols,omitempty"`
	//
	// Width of the player in pixels. This field is not required, but it’s highly recommended.
	W *int32 `protobuf:"varint,6,opt,name=w" json:"w,omitempty"`
	//
	// Height of the player in pixels. This field is not required, but it’s highly recommended.
	H *int32 `protobuf:"varint,7,opt,name=h" json:"h,omitempty"`
	//
	// Indicates the start delay in seconds for preroll, midroll, or postroll ad placement.
	// Check the enum VideoStartDelay for special values.
	Startdelay *int32 `protobuf:"varint,8,opt,name=startdelay,def=-3" json:"startdelay,omitempty"`
	//
	// If multiple ad impressions are offered in the same bid request, the sequence number
	// will allow for the coordinated delivery of multiple creatives.
	Sequence *int32 `protobuf:"varint,9,opt,name=sequence,def=1" json:"sequence,omitempty"`
	//
	// Blocked creative attributes. If blank assume all types are allowed.
	Battr []CreativeAttribute `protobuf:"varint,10,rep,name=battr,enum=openrtb.CreativeAttribute" json:"battr,omitempty"`
	//
	// Maximum extended video ad duration, if extension is allowed.
	// If blank or 0, extension is not allowed. If -1, extension is allowed, and there is
	// no time limit imposed. If greater than 0, then the value represents the number of
	// seconds of extended play supported beyond the maxduration value.
	Maxextended *int32 `protobuf:"varint,11,opt,name=maxextended,def=0" json:"maxextended,omitempty"`
	//
	// Minimum bit rate in Kbps. Exchange may set this dynamically,
	// or universally across their set of publishers.
	Minbitrate *int32 `protobuf:"varint,12,opt,name=minbitrate" json:"minbitrate,omitempty"`
	//
	// Maximum bit rate in Kbps. Exchange may set this dynamically,
	// or universally across their set of publishers.
	Maxbitrate *int32 `protobuf:"varint,13,opt,name=maxbitrate" json:"maxbitrate,omitempty"`
	//
	// If exchange publisher has rules preventing letter boxing of 4x3 content to play in a
	// 16x9 window, then this should be set to false. Default setting is true, which assumes
	// that boxing of content to fit into a window is allowed.
	Boxingallowed *Flag `protobuf:"varint,14,opt,name=boxingallowed,enum=openrtb.Flag,def=1" json:"boxingallowed,omitempty"`
	//
	// List of allowed playback methods. If blank, assume that all are allowed.
	Playbackmethod []Enums_BidRequest_Impression_Video_PlaybackMethod `protobuf:"varint,15,rep,name=playbackmethod,enum=openrtb.Enums_BidRequest_Impression_Video_PlaybackMethod" json:"playbackmethod,omitempty"`
	//
	// List of supported delivery methods. If blank, assume all are supported.
	Delivery []Enums_BidRequest_Impression_Video_ContentDelivery `protobuf:"varint,16,rep,name=delivery,enum=openrtb.Enums_BidRequest_Impression_Video_ContentDelivery" json:"delivery,omitempty"`
	//
	// The position of the ad as a relative measure of visibility or prominence.
	Pos *Enums_BidRequest_Impression_AdPosition `protobuf:"varint,17,opt,name=pos,enum=openrtb.Enums_BidRequest_Impression_AdPosition,def=0" json:"pos,omitempty"`
	//
	// If companion ads are available, they can be listed as an array of banner objects.
	Companionad []*BidRequest_Impression_Banner `protobuf:"bytes,18,rep,name=companionad" json:"companionad,omitempty"`
	//
	// List of supported API frameworks for this banner. If an API is not explicitly listed
	// it is assumed not to be supported.
	Api []Enums_BidRequest_Impression_ApiFramework `protobuf:"varint,19,rep,name=api,enum=openrtb.Enums_BidRequest_Impression_ApiFramework" json:"api,omitempty"`
	//
	// Recommended if companion objects are included.
	Companiontype []Enums_BidRequest_Impression_Video_CompanionType `protobuf:"varint,20,rep,name=companiontype,enum=openrtb.Enums_BidRequest_Impression_Video_CompanionType" json:"companiontype,omitempty"`
	//
	// Placement type for the impression.
	Placement *Enums_BidRequest_Impression_Video_VideoPlacementType `protobuf:"varint,26,opt,name=placement,enum=openrtb.Enums_BidRequest_Impression_Video_VideoPlacementType" json:"placement,omitempty"`
	//
	// The event that causes playback to end.
	Playbackend      *Enums_BidRequest_Impression_Video_PlaybackCessationMode `protobuf:"varint,27,opt,name=playbackend,enum=openrtb.Enums_BidRequest_Impression_Video_PlaybackCessationMode" json:"playbackend,omitempty"`
	Ext              *VideoExtensions                                         `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                                                   `json:"-"`
}

func (m *BidRequest_Impression_Video) Reset()         { *m = BidRequest_Impression_Video{} }
func (m *BidRequest_Impression_Video) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Impression_Video) ProtoMessage()    {}
func (*BidRequest_Impression_Video) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 1, 1}
}

const Default_BidRequest_Impression_Video_Linearity Enums_BidRequest_Impression_Video_Linearity = Enums_BidRequest_Impression_Video_LINEAR
const Default_BidRequest_Impression_Video_Startdelay int32 = -3
const Default_BidRequest_Impression_Video_Sequence int32 = 1
const Default_BidRequest_Impression_Video_Maxextended int32 = 0
const Default_BidRequest_Impression_Video_Boxingallowed Flag = Flag_YES
const Default_BidRequest_Impression_Video_Pos Enums_BidRequest_Impression_AdPosition = Enums_BidRequest_Impression_POSITION_UNKNOWN

func (m *BidRequest_Impression_Video) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetLinearity() Enums_BidRequest_Impression_Video_Linearity {
	if m != nil && m.Linearity != nil {
		return *m.Linearity
	}
	return Default_BidRequest_Impression_Video_Linearity
}

func (m *BidRequest_Impression_Video) GetMinduration() int32 {
	if m != nil && m.Minduration != nil {
		return *m.Minduration
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetMaxduration() int32 {
	if m != nil && m.Maxduration != nil {
		return *m.Maxduration
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetProtocols() []Enums_BidRequest_Impression_Video_Protocol {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetStartdelay() int32 {
	if m != nil && m.Startdelay != nil {
		return *m.Startdelay
	}
	return Default_BidRequest_Impression_Video_Startdelay
}

func (m *BidRequest_Impression_Video) GetSequence() int32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return Default_BidRequest_Impression_Video_Sequence
}

func (m *BidRequest_Impression_Video) GetBattr() []CreativeAttribute {
	if m != nil {
		return m.Battr
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetMaxextended() int32 {
	if m != nil && m.Maxextended != nil {
		return *m.Maxextended
	}
	return Default_BidRequest_Impression_Video_Maxextended
}

func (m *BidRequest_Impression_Video) GetMinbitrate() int32 {
	if m != nil && m.Minbitrate != nil {
		return *m.Minbitrate
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetMaxbitrate() int32 {
	if m != nil && m.Maxbitrate != nil {
		return *m.Maxbitrate
	}
	return 0
}

func (m *BidRequest_Impression_Video) GetBoxingallowed() Flag {
	if m != nil && m.Boxingallowed != nil {
		return *m.Boxingallowed
	}
	return Default_BidRequest_Impression_Video_Boxingallowed
}

func (m *BidRequest_Impression_Video) GetPlaybackmethod() []Enums_BidRequest_Impression_Video_PlaybackMethod {
	if m != nil {
		return m.Playbackmethod
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetDelivery() []Enums_BidRequest_Impression_Video_ContentDelivery {
	if m != nil {
		return m.Delivery
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetPos() Enums_BidRequest_Impression_AdPosition {
	if m != nil && m.Pos != nil {
		return *m.Pos
	}
	return Default_BidRequest_Impression_Video_Pos
}

func (m *BidRequest_Impression_Video) GetCompanionad() []*BidRequest_Impression_Banner {
	if m != nil {
		return m.Companionad
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetApi() []Enums_BidRequest_Impression_ApiFramework {
	if m != nil {
		return m.Api
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetCompaniontype() []Enums_BidRequest_Impression_Video_CompanionType {
	if m != nil {
		return m.Companiontype
	}
	return nil
}

func (m *BidRequest_Impression_Video) GetPlacement() Enums_BidRequest_Impression_Video_VideoPlacementType {
	if m != nil && m.Placement != nil {
		return *m.Placement
	}
	return Enums_BidRequest_Impression_Video_UNDEFINED_VIDEO_PLACEMENT
}

func (m *BidRequest_Impression_Video) GetPlaybackend() Enums_BidRequest_Impression_Video_PlaybackCessationMode {
	if m != nil && m.Playbackend != nil {
		return *m.Playbackend
	}
	return Enums_BidRequest_Impression_Video_COMPLETION_OR_USER
}

func (m *BidRequest_Impression_Video) GetExt() *VideoExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

// *
// OpenRTB 3.2.5: This object represents a native type impression.
// Native ad units are intended to blend seamlessly into the surrounding content
// (e.g., a sponsored Twitter or Facebook post). As such, the response must be
// well-structured to afford the publisher fine-grained control over rendering.
//
// The Native Subcommittee has developed a companion specification to OpenRTB
// called the Native Ad Specification. It defines the request parameters and response markup
// structure of native ad units. This object provides the means of transporting request
// parameters as an opaque string so that the specific parameters can evolve separately
// under the auspices of the Native Ad Specification. Similarly, the ad markup served
// will be structured according to that specification.
//
// The presence of a Native as a subordinate of the Imp object indicates that this
// impression is offered as a native type impression. At the publisher's discretion,
// that same impression may also be offered as banner and/or video by also including as
// Imp subordinates the Banner and/or Video objects, respectively.
// However, any given bid for the impression must conform to one of the offered types.
type BidRequest_Impression_Native struct {
	// *
	// Request payload complying with the Native Ad Specification.
	Request *NativeRequest `protobuf:"bytes,1,req,name=request" json:"request,omitempty"`
	// *
	// Version of the Native Ad Specification to which request complies;
	// highly recommended for efficient parsing.
	Ver *string `protobuf:"bytes,2,opt,name=ver" json:"ver,omitempty"`
	// *
	// List of supported API frameworks for this impression.  Refer to List 5.6.
	// If an API is not explicitly listed, it is assumed not to be supported.
	Api []Enums_BidRequest_Impression_ApiFramework `protobuf:"varint,3,rep,packed,name=api,enum=openrtb.Enums_BidRequest_Impression_ApiFramework" json:"api,omitempty"`
	// *
	// Blocked creative attributes. Refer to List 5.3.
	Battr            []CreativeAttribute `protobuf:"varint,4,rep,packed,name=battr,enum=openrtb.CreativeAttribute" json:"battr,omitempty"`
	Ext              *NativeExtensions   `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *BidRequest_Impression_Native) Reset()         { *m = BidRequest_Impression_Native{} }
func (m *BidRequest_Impression_Native) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Impression_Native) ProtoMessage()    {}
func (*BidRequest_Impression_Native) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 1, 2}
}

func (m *BidRequest_Impression_Native) GetRequest() *NativeRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *BidRequest_Impression_Native) GetVer() string {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return ""
}

func (m *BidRequest_Impression_Native) GetApi() []Enums_BidRequest_Impression_ApiFramework {
	if m != nil {
		return m.Api
	}
	return nil
}

func (m *BidRequest_Impression_Native) GetBattr() []CreativeAttribute {
	if m != nil {
		return m.Battr
	}
	return nil
}

func (m *BidRequest_Impression_Native) GetExt() *NativeExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.16: contains a parent object for usage within the context of private
// marketplaces and the use of the RTB protocol to execute Direct Deals.
type BidRequest_Impression_PMP struct {
	//
	// Flag indicating that this impression is a private auction eligible only to seats named
	// in the DirectDeals object.
	PrivateAuction *Flag `protobuf:"varint,1,opt,name=private_auction,json=privateAuction,enum=openrtb.Flag" json:"private_auction,omitempty"`
	//
	// A collection of deal objects encapsulating a list of direct deals eligible for
	// this impression.
	Deals            []*BidRequest_Impression_PMP_DirectDeal `protobuf:"bytes,2,rep,name=deals" json:"deals,omitempty"`
	Ext              *PMPExtensions                          `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                                  `json:"-"`
}

func (m *BidRequest_Impression_PMP) Reset()         { *m = BidRequest_Impression_PMP{} }
func (m *BidRequest_Impression_PMP) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Impression_PMP) ProtoMessage()    {}
func (*BidRequest_Impression_PMP) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 1, 3}
}

func (m *BidRequest_Impression_PMP) GetPrivateAuction() Flag {
	if m != nil && m.PrivateAuction != nil {
		return *m.PrivateAuction
	}
	return Flag_NO
}

func (m *BidRequest_Impression_PMP) GetDeals() []*BidRequest_Impression_PMP_DirectDeal {
	if m != nil {
		return m.Deals
	}
	return nil
}

func (m *BidRequest_Impression_PMP) GetExt() *PMPExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.17: constitutes a deal struck a priori between a buyer and a seller and
// indicates that this impression is available under the terms of that deal.
type BidRequest_Impression_PMP_DirectDeal struct {
	//
	// A unique identifier for the direct deal.
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	//
	// Bid floor for this impression (in CPM of bidfloorcur).
	Bidfloor *float64 `protobuf:"fixed64,2,opt,name=bidfloor,def=0" json:"bidfloor,omitempty"`
	//
	// If bid floor is specified and multiple currencies supported per bid request,
	// then currency should be specified here using ISO-4217 alphabetic codes. Notes.
	// this may be different from bid currency returned by bidder, if this is allowed
	// on an exchange.
	Bidfloorcur *string `protobuf:"bytes,3,opt,name=bidfloorcur,def=USD" json:"bidfloorcur,omitempty"`
	//
	// Array of buyer seats allowed to bid on this auction. Seats are an optional feature
	// of exchange. For example, [“4”,”34”,”82”,”A45”] indicates that only advertisers
	// using these exchange seats are allowed to bid on the impressions in this auction.
	Wseat []string `protobuf:"bytes,4,rep,name=wseat" json:"wseat,omitempty"`
	//
	// Array of advertiser domains allowed to bid on this Direct Deal. For example,
	// [ "advertiser1.com", "advertiser2.com" ] indicates that only the listed
	// advertisers are allowed to bid on this direct deal.
	Wadomain []string `protobuf:"bytes,5,rep,name=wadomain" json:"wadomain,omitempty"`
	//
	// Auction Type. If “1”, then first price auction. If “2”, then second price auction.
	// Additional auction types can be defined as per the exchange’s business rules.
	At               *int32                `protobuf:"varint,6,opt,name=at" json:"at,omitempty"`
	Ext              *DirectDealExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *BidRequest_Impression_PMP_DirectDeal) Reset()         { *m = BidRequest_Impression_PMP_DirectDeal{} }
func (m *BidRequest_Impression_PMP_DirectDeal) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Impression_PMP_DirectDeal) ProtoMessage()    {}
func (*BidRequest_Impression_PMP_DirectDeal) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 1, 3, 0}
}

const Default_BidRequest_Impression_PMP_DirectDeal_Bidfloor float64 = 0
const Default_BidRequest_Impression_PMP_DirectDeal_Bidfloorcur string = "USD"

func (m *BidRequest_Impression_PMP_DirectDeal) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetBidfloor() float64 {
	if m != nil && m.Bidfloor != nil {
		return *m.Bidfloor
	}
	return Default_BidRequest_Impression_PMP_DirectDeal_Bidfloor
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetBidfloorcur() string {
	if m != nil && m.Bidfloorcur != nil {
		return *m.Bidfloorcur
	}
	return Default_BidRequest_Impression_PMP_DirectDeal_Bidfloorcur
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetWseat() []string {
	if m != nil {
		return m.Wseat
	}
	return nil
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetWadomain() []string {
	if m != nil {
		return m.Wadomain
	}
	return nil
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetAt() int32 {
	if m != nil && m.At != nil {
		return *m.At
	}
	return 0
}

func (m *BidRequest_Impression_PMP_DirectDeal) GetExt() *DirectDealExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.5: should be included if the ad supported content is part of a website
// (as opposed to an application).
type BidRequest_Site struct {
	//
	// Site ID on the exchange.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Site name (may be masked at publisher’s request).
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	//
	// Domain of the site, used for advertiser side blocking. For example, “foo.com”.
	Domain *string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
	//
	// Array of IAB content categories for the overall site.
	Cat []string `protobuf:"bytes,4,rep,name=cat" json:"cat,omitempty"`
	//
	// Array of IAB content categories for the current subsection of the site.
	Sectioncat []string `protobuf:"bytes,5,rep,name=sectioncat" json:"sectioncat,omitempty"`
	//
	// Array of IAB content categories for the current page.
	Pagecat []string `protobuf:"bytes,6,rep,name=pagecat" json:"pagecat,omitempty"`
	//
	// URL of the page where the impression will be shown.
	Page *string `protobuf:"bytes,7,opt,name=page" json:"page,omitempty"`
	//
	// Specifies whether the site has a privacy policy.
	Privacypolicy *Flag `protobuf:"varint,8,opt,name=privacypolicy,enum=openrtb.Flag" json:"privacypolicy,omitempty"`
	//
	// Referrer URL that caused navigation to the current page.
	Ref *string `protobuf:"bytes,10,opt,name=ref" json:"ref,omitempty"`
	//
	// Search string that caused navigation to the current page.
	Search *string `protobuf:"bytes,11,opt,name=search" json:"search,omitempty"`
	//
	// Mobile-optimized signal, where 0 = no, 1 = yes.
	Mobile *bool `protobuf:"varint,15,opt,name=mobile" json:"mobile,omitempty"`
	//
	// Site's Publisher.
	Publisher *BidRequest_Publisher `protobuf:"bytes,12,opt,name=publisher" json:"publisher,omitempty"`
	//
	// Site's Content.
	Content *BidRequest_Content `protobuf:"bytes,13,opt,name=content" json:"content,omitempty"`
	//
	// List of keywords describing this site in a comma separated string.
	Keywords         *string         `protobuf:"bytes,14,opt,name=keywords" json:"keywords,omitempty"`
	Ext              *SiteExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *BidRequest_Site) Reset()                    { *m = BidRequest_Site{} }
func (m *BidRequest_Site) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Site) ProtoMessage()               {}
func (*BidRequest_Site) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 2} }

func (m *BidRequest_Site) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Site) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BidRequest_Site) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *BidRequest_Site) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidRequest_Site) GetSectioncat() []string {
	if m != nil {
		return m.Sectioncat
	}
	return nil
}

func (m *BidRequest_Site) GetPagecat() []string {
	if m != nil {
		return m.Pagecat
	}
	return nil
}

func (m *BidRequest_Site) GetPage() string {
	if m != nil && m.Page != nil {
		return *m.Page
	}
	return ""
}

func (m *BidRequest_Site) GetPrivacypolicy() Flag {
	if m != nil && m.Privacypolicy != nil {
		return *m.Privacypolicy
	}
	return Flag_NO
}

func (m *BidRequest_Site) GetRef() string {
	if m != nil && m.Ref != nil {
		return *m.Ref
	}
	return ""
}

func (m *BidRequest_Site) GetSearch() string {
	if m != nil && m.Search != nil {
		return *m.Search
	}
	return ""
}

func (m *BidRequest_Site) GetMobile() bool {
	if m != nil && m.Mobile != nil {
		return *m.Mobile
	}
	return false
}

func (m *BidRequest_Site) GetPublisher() *BidRequest_Publisher {
	if m != nil {
		return m.Publisher
	}
	return nil
}

func (m *BidRequest_Site) GetContent() *BidRequest_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BidRequest_Site) GetKeywords() string {
	if m != nil && m.Keywords != nil {
		return *m.Keywords
	}
	return ""
}

func (m *BidRequest_Site) GetExt() *SiteExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.6: should be included if the ad supported content is part of a mobile application
// (as opposed to a mobile website).
type BidRequest_App struct {
	//
	// Application ID on the exchange.
	Id *string `protobuf:"bytes,1,opt,name=id,def=-1" json:"id,omitempty"`
	//
	// Application name (may be masked at publisher’s request).
	Name *string `protobuf:"bytes,2,opt,name=name,def=-1" json:"name,omitempty"`
	//
	// Domain of the application. For example, “mygame.foo.com”.
	Domain *string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
	//
	// Array of IAB content categories for the overall application.
	Cat []string `protobuf:"bytes,4,rep,name=cat" json:"cat,omitempty"`
	//
	// Array of IAB content categories for the current subsection of the application.
	Sectioncat []string `protobuf:"bytes,5,rep,name=sectioncat" json:"sectioncat,omitempty"`
	//
	// Array of IAB content categories for the current page/view of the app.
	Pagecat []string `protobuf:"bytes,6,rep,name=pagecat" json:"pagecat,omitempty"`
	//
	// Application version.
	Ver *string `protobuf:"bytes,7,opt,name=ver" json:"ver,omitempty"`
	//
	// Application bundle or package name (e.g., com.foo.mygame). This is intended to be a
	// unique ID across multiple exchanges.
	Bundle *string `protobuf:"bytes,8,opt,name=bundle,def=-1" json:"bundle,omitempty"`
	//
	// Specifies whether the application has a privacy policy.
	Privacypolicy *Flag `protobuf:"varint,9,opt,name=privacypolicy,enum=openrtb.Flag" json:"privacypolicy,omitempty"`
	//
	// Application is a paid version or free.
	Paid *Flag `protobuf:"varint,10,opt,name=paid,enum=openrtb.Flag" json:"paid,omitempty"`
	//
	// Application's Publisher.
	Publisher *BidRequest_Publisher `protobuf:"bytes,11,opt,name=publisher" json:"publisher,omitempty"`
	//
	// Application's Content.
	Content *BidRequest_Content `protobuf:"bytes,12,opt,name=content" json:"content,omitempty"`
	//
	// List of keywords describing this site in a comma separated string.
	Keywords *string `protobuf:"bytes,13,opt,name=keywords" json:"keywords,omitempty"`
	//
	// For QAG 1.5 compliance, an app store URL for an installed app
	// should be passed in the bid request.
	Storeurl         *string        `protobuf:"bytes,14,opt,name=storeurl" json:"storeurl,omitempty"`
	Ext              *AppExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *BidRequest_App) Reset()                    { *m = BidRequest_App{} }
func (m *BidRequest_App) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_App) ProtoMessage()               {}
func (*BidRequest_App) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 3} }

const Default_BidRequest_App_Id string = "-1"
const Default_BidRequest_App_Name string = "-1"
const Default_BidRequest_App_Bundle string = "-1"

func (m *BidRequest_App) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return Default_BidRequest_App_Id
}

func (m *BidRequest_App) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return Default_BidRequest_App_Name
}

func (m *BidRequest_App) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *BidRequest_App) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidRequest_App) GetSectioncat() []string {
	if m != nil {
		return m.Sectioncat
	}
	return nil
}

func (m *BidRequest_App) GetPagecat() []string {
	if m != nil {
		return m.Pagecat
	}
	return nil
}

func (m *BidRequest_App) GetVer() string {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return ""
}

func (m *BidRequest_App) GetBundle() string {
	if m != nil && m.Bundle != nil {
		return *m.Bundle
	}
	return Default_BidRequest_App_Bundle
}

func (m *BidRequest_App) GetPrivacypolicy() Flag {
	if m != nil && m.Privacypolicy != nil {
		return *m.Privacypolicy
	}
	return Flag_NO
}

func (m *BidRequest_App) GetPaid() Flag {
	if m != nil && m.Paid != nil {
		return *m.Paid
	}
	return Flag_NO
}

func (m *BidRequest_App) GetPublisher() *BidRequest_Publisher {
	if m != nil {
		return m.Publisher
	}
	return nil
}

func (m *BidRequest_App) GetContent() *BidRequest_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BidRequest_App) GetKeywords() string {
	if m != nil && m.Keywords != nil {
		return *m.Keywords
	}
	return ""
}

func (m *BidRequest_App) GetStoreurl() string {
	if m != nil && m.Storeurl != nil {
		return *m.Storeurl
	}
	return ""
}

func (m *BidRequest_App) GetExt() *AppExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.7: describes the content of a site or app.
// This object may be useful in the situation where syndicated content contains impressions and
// does not necessarily match the publisher’s general content. The exchange might or might not
// have knowledge of the page where the content is running, as a result of the syndication method.
// (For example, video impressions embedded in an iframe on an unknown web property or device.)
type BidRequest_Content struct {
	//
	// ID uniquely identifying the content.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Content episode number (typically applies to video content).
	Episode *int32 `protobuf:"varint,2,opt,name=episode" json:"episode,omitempty"`
	//
	// Content title.
	Title *string `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	//
	// Content series.
	Series *string `protobuf:"bytes,4,opt,name=series" json:"series,omitempty"`
	//
	// Content season.
	Season *string `protobuf:"bytes,5,opt,name=season" json:"season,omitempty"`
	//
	// Original URL of the content, for buy-side contextualization or review.
	Url *string `protobuf:"bytes,6,opt,name=url" json:"url,omitempty"`
	//
	// Array of IAB content categories for the content.
	Cat []string `protobuf:"bytes,7,rep,name=cat" json:"cat,omitempty"`
	//
	// Video quality per the IAB’s classification.
	Videoquality *Enums_BidRequest_Content_VideoQuality `protobuf:"varint,8,opt,name=videoquality,enum=openrtb.Enums_BidRequest_Content_VideoQuality" json:"videoquality,omitempty"`
	//
	// Comma separated list of keywords describing the content.
	Keywords *string `protobuf:"bytes,9,opt,name=keywords" json:"keywords,omitempty"`
	//
	// Content rating (e.g., MPAA).
	Contentrating *string `protobuf:"bytes,10,opt,name=contentrating" json:"contentrating,omitempty"`
	//
	// User rating of the content (e.g., number of stars, likes, etc.).
	Userrating *string `protobuf:"bytes,11,opt,name=userrating" json:"userrating,omitempty"`
	//
	// Specifies the type of content (game, video, text, etc.).
	Context *Enums_BidRequest_Content_Context `protobuf:"varint,12,opt,name=context,enum=openrtb.Enums_BidRequest_Content_Context" json:"context,omitempty"`
	//
	// Is content live?
	Livestream *Flag `protobuf:"varint,13,opt,name=livestream,enum=openrtb.Flag" json:"livestream,omitempty"`
	//
	// Direct or indirect.
	Sourcerelationship *Enums_BidRequest_Content_SourceRelationship `protobuf:"varint,14,opt,name=sourcerelationship,enum=openrtb.Enums_BidRequest_Content_SourceRelationship" json:"sourcerelationship,omitempty"`
	//
	// Content's Producer.
	Producer *BidRequest_Producer `protobuf:"bytes,15,opt,name=producer" json:"producer,omitempty"`
	//
	// Length of content (appropriate for video or audio) in seconds.
	Len *int32 `protobuf:"varint,16,opt,name=len" json:"len,omitempty"`
	//
	// Media rating of the content, per QAG guidelines.
	Qagmediarating *Enums_BidRequest_Content_QAGMediaRating `protobuf:"varint,17,opt,name=qagmediarating,enum=openrtb.Enums_BidRequest_Content_QAGMediaRating,def=-1" json:"qagmediarating,omitempty"`
	//
	// From QAG Video Addendum. If content can be embedded (such as an embeddable video player)
	// this value should be set to YES. If content cannot be embedded, this should be set to NO.
	Embeddable *Flag `protobuf:"varint,18,opt,name=embeddable,enum=openrtb.Flag" json:"embeddable,omitempty"`
	//
	// Language of the content. Use alpha-2/ISO 639-1 codes.
	Language         *string            `protobuf:"bytes,19,opt,name=language" json:"language,omitempty"`
	Ext              *ContentExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *BidRequest_Content) Reset()                    { *m = BidRequest_Content{} }
func (m *BidRequest_Content) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Content) ProtoMessage()               {}
func (*BidRequest_Content) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 4} }

const Default_BidRequest_Content_Qagmediarating Enums_BidRequest_Content_QAGMediaRating = Enums_BidRequest_Content_UNKNOWN

func (m *BidRequest_Content) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Content) GetEpisode() int32 {
	if m != nil && m.Episode != nil {
		return *m.Episode
	}
	return 0
}

func (m *BidRequest_Content) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *BidRequest_Content) GetSeries() string {
	if m != nil && m.Series != nil {
		return *m.Series
	}
	return ""
}

func (m *BidRequest_Content) GetSeason() string {
	if m != nil && m.Season != nil {
		return *m.Season
	}
	return ""
}

func (m *BidRequest_Content) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *BidRequest_Content) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidRequest_Content) GetVideoquality() Enums_BidRequest_Content_VideoQuality {
	if m != nil && m.Videoquality != nil {
		return *m.Videoquality
	}
	return Enums_BidRequest_Content_QUALITY_UNKNOWN
}

func (m *BidRequest_Content) GetKeywords() string {
	if m != nil && m.Keywords != nil {
		return *m.Keywords
	}
	return ""
}

func (m *BidRequest_Content) GetContentrating() string {
	if m != nil && m.Contentrating != nil {
		return *m.Contentrating
	}
	return ""
}

func (m *BidRequest_Content) GetUserrating() string {
	if m != nil && m.Userrating != nil {
		return *m.Userrating
	}
	return ""
}

func (m *BidRequest_Content) GetContext() Enums_BidRequest_Content_Context {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return Enums_BidRequest_Content_VIDEO
}

func (m *BidRequest_Content) GetLivestream() Flag {
	if m != nil && m.Livestream != nil {
		return *m.Livestream
	}
	return Flag_NO
}

func (m *BidRequest_Content) GetSourcerelationship() Enums_BidRequest_Content_SourceRelationship {
	if m != nil && m.Sourcerelationship != nil {
		return *m.Sourcerelationship
	}
	return Enums_BidRequest_Content_INDIRECT
}

func (m *BidRequest_Content) GetProducer() *BidRequest_Producer {
	if m != nil {
		return m.Producer
	}
	return nil
}

func (m *BidRequest_Content) GetLen() int32 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

func (m *BidRequest_Content) GetQagmediarating() Enums_BidRequest_Content_QAGMediaRating {
	if m != nil && m.Qagmediarating != nil {
		return *m.Qagmediarating
	}
	return Default_BidRequest_Content_Qagmediarating
}

func (m *BidRequest_Content) GetEmbeddable() Flag {
	if m != nil && m.Embeddable != nil {
		return *m.Embeddable
	}
	return Flag_NO
}

func (m *BidRequest_Content) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *BidRequest_Content) GetExt() *ContentExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.10: Provides information pertaining to the device including its hardware,
// platform, location, and carrier. This device can refer to a mobile handset, a desktop
// computer, set top box or other digital device. In general, the most essential fields are
// either the IP address (to enable geo-lookup for the bidder), or providing geo information
// directly in the geo object.
type BidRequest_Device struct {
	//
	// Do Not Track.
	Dnt *Flag `protobuf:"varint,1,opt,name=dnt,enum=openrtb.Flag" json:"dnt,omitempty"`
	//
	// Browser user agent string.
	Ua *string `protobuf:"bytes,2,opt,name=ua" json:"ua,omitempty"`
	//
	// IPv4 address closest to device.
	Ip *string `protobuf:"bytes,3,opt,name=ip,def=0.0.0.0" json:"ip,omitempty"`
	//
	// Geography as derived from the device’s location services (e.g., cell tower triangulation,
	// GPS) or IP address.
	Geo *BidRequest_Geo `protobuf:"bytes,4,opt,name=geo" json:"geo,omitempty"`
	//
	// SHA1 hashed device ID; IMEI when available, else MEID or ESN.
	// OpenRTB’s preferred method for device ID hashing is SHA1.
	Didsha1 *string `protobuf:"bytes,5,opt,name=didsha1" json:"didsha1,omitempty"`
	//
	// MD5 hashed device ID; IMEI when available, else MEID or ESN.
	// Should be interpreted as case insensitive.
	Didmd5 *string `protobuf:"bytes,6,opt,name=didmd5" json:"didmd5,omitempty"`
	//
	// SHA1 hashed platform-specific ID (e.g., Android ID or UDID for iOS).
	// OpenRTB’s preferred method for device ID hash is SHA1.
	Dpidsha1 *string `protobuf:"bytes,7,opt,name=dpidsha1" json:"dpidsha1,omitempty"`
	//
	// MD5 hashed platform-specific ID (e.g., Android ID or UDID for iOS).
	// Should be interpreted as case insensitive.
	Dpidmd5 *string `protobuf:"bytes,8,opt,name=dpidmd5" json:"dpidmd5,omitempty"`
	//
	// IP address in IPv6.
	Ipv6 *string `protobuf:"bytes,9,opt,name=ipv6" json:"ipv6,omitempty"`
	//
	// Carrier or ISP derived from the IP address.
	// Should be specified using Mobile Network Code (MNC).
	Carrier *string `protobuf:"bytes,10,opt,name=carrier,def=-1" json:"carrier,omitempty"`
	//
	// Browser language; use alpha-2/ISO 639-1 codes.
	Language *string `protobuf:"bytes,11,opt,name=language" json:"language,omitempty"`
	//
	// Device make (e.g., “Apple”).
	Make *string `protobuf:"bytes,12,opt,name=make,def=-1" json:"make,omitempty"`
	//
	// Device model (e.g., “iPhone”).
	Model *string `protobuf:"bytes,13,opt,name=model,def=-1" json:"model,omitempty"`
	//
	// Device operating system (e.g., “iOS”).
	Os *string `protobuf:"bytes,14,opt,name=os,def=-1" json:"os,omitempty"`
	//
	// Device operating system version (e.g., “3.1.2”).
	Osv *string `protobuf:"bytes,15,opt,name=osv,def=-1" json:"osv,omitempty"`
	//
	// Device supports Javascript?
	Js *Flag `protobuf:"varint,16,opt,name=js,enum=openrtb.Flag,def=1" json:"js,omitempty"`
	//
	// Return the detected data connection type for the device.
	Connectiontype *Enums_BidRequest_Device_ConnectionType `protobuf:"varint,17,opt,name=connectiontype,enum=openrtb.Enums_BidRequest_Device_ConnectionType,def=0" json:"connectiontype,omitempty"`
	//
	// Return the device type being used.
	Devicetype *Enums_BidRequest_Device_DeviceType `protobuf:"varint,18,opt,name=devicetype,enum=openrtb.Enums_BidRequest_Device_DeviceType,def=-1" json:"devicetype,omitempty"`
	//
	// Return the Flash version detected.
	Flashver *string `protobuf:"bytes,19,opt,name=flashver" json:"flashver,omitempty"`
	//
	// "Limit Ad Tracking" signal commercially endorsed (e.g., iOS, Android),
	// where false = tracking is unrestricted,
	// true = tracking must be limited per commercial guidelines.
	Lmt *bool `protobuf:"varint,20,opt,name=lmt" json:"lmt,omitempty"`
	//
	// Hardware version of the device (e.g., "5S" for iPhone 5S).
	Hwv *string `protobuf:"bytes,21,opt,name=hwv" json:"hwv,omitempty"`
	//
	// Physical width of the screen in pixels.
	W *int32 `protobuf:"varint,22,opt,name=w" json:"w,omitempty"`
	//
	// Physical height of the screen in pixels.
	H *int32 `protobuf:"varint,23,opt,name=h" json:"h,omitempty"`
	//
	// Screen size as pixels per linear inch.
	Ppi *int32 `protobuf:"varint,24,opt,name=ppi" json:"ppi,omitempty"`
	//
	// The ratio of physical pixels to device independent pixels.
	Pxratio *float64 `protobuf:"fixed64,25,opt,name=pxratio" json:"pxratio,omitempty"`
	//
	// ID sanctioned for advertiser use in the clear (i.e., not hashed).
	Ifa *string `protobuf:"bytes,26,opt,name=ifa" json:"ifa,omitempty"`
	//
	// MAC address of the device; hashed via SHA1.
	Macsha1 *string `protobuf:"bytes,27,opt,name=macsha1" json:"macsha1,omitempty"`
	// *
	// MAC address of the device; hashed via MD5.
	Macmd5 *string `protobuf:"bytes,28,opt,name=macmd5" json:"macmd5,omitempty"`
	//
	// Mobile carrier as the concatenated MCC-MNC code (e.g.,
	// "310-005" identifies Verizon Wireless CDMA in the USA).
	// Refer to https://en.wikipedia.org/wiki/Mobile_country_code
	// for further examples. Note that the dash between the MCC
	// and MNC parts is required to remove parsing ambiguity.
	Mccmnc           *string           `protobuf:"bytes,30,opt,name=mccmnc" json:"mccmnc,omitempty"`
	Ext              *DeviceExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *BidRequest_Device) Reset()                    { *m = BidRequest_Device{} }
func (m *BidRequest_Device) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Device) ProtoMessage()               {}
func (*BidRequest_Device) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 5} }

const Default_BidRequest_Device_Ip string = "0.0.0.0"
const Default_BidRequest_Device_Carrier string = "-1"
const Default_BidRequest_Device_Make string = "-1"
const Default_BidRequest_Device_Model string = "-1"
const Default_BidRequest_Device_Os string = "-1"
const Default_BidRequest_Device_Osv string = "-1"
const Default_BidRequest_Device_Js Flag = Flag_YES
const Default_BidRequest_Device_Connectiontype Enums_BidRequest_Device_ConnectionType = Enums_BidRequest_Device_CONNECTION_UNKNOWN
const Default_BidRequest_Device_Devicetype Enums_BidRequest_Device_DeviceType = Enums_BidRequest_Device_UNKNOWN

func (m *BidRequest_Device) GetDnt() Flag {
	if m != nil && m.Dnt != nil {
		return *m.Dnt
	}
	return Flag_NO
}

func (m *BidRequest_Device) GetUa() string {
	if m != nil && m.Ua != nil {
		return *m.Ua
	}
	return ""
}

func (m *BidRequest_Device) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return Default_BidRequest_Device_Ip
}

func (m *BidRequest_Device) GetGeo() *BidRequest_Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *BidRequest_Device) GetDidsha1() string {
	if m != nil && m.Didsha1 != nil {
		return *m.Didsha1
	}
	return ""
}

func (m *BidRequest_Device) GetDidmd5() string {
	if m != nil && m.Didmd5 != nil {
		return *m.Didmd5
	}
	return ""
}

func (m *BidRequest_Device) GetDpidsha1() string {
	if m != nil && m.Dpidsha1 != nil {
		return *m.Dpidsha1
	}
	return ""
}

func (m *BidRequest_Device) GetDpidmd5() string {
	if m != nil && m.Dpidmd5 != nil {
		return *m.Dpidmd5
	}
	return ""
}

func (m *BidRequest_Device) GetIpv6() string {
	if m != nil && m.Ipv6 != nil {
		return *m.Ipv6
	}
	return ""
}

func (m *BidRequest_Device) GetCarrier() string {
	if m != nil && m.Carrier != nil {
		return *m.Carrier
	}
	return Default_BidRequest_Device_Carrier
}

func (m *BidRequest_Device) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *BidRequest_Device) GetMake() string {
	if m != nil && m.Make != nil {
		return *m.Make
	}
	return Default_BidRequest_Device_Make
}

func (m *BidRequest_Device) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return Default_BidRequest_Device_Model
}

func (m *BidRequest_Device) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return Default_BidRequest_Device_Os
}

func (m *BidRequest_Device) GetOsv() string {
	if m != nil && m.Osv != nil {
		return *m.Osv
	}
	return Default_BidRequest_Device_Osv
}

func (m *BidRequest_Device) GetJs() Flag {
	if m != nil && m.Js != nil {
		return *m.Js
	}
	return Default_BidRequest_Device_Js
}

func (m *BidRequest_Device) GetConnectiontype() Enums_BidRequest_Device_ConnectionType {
	if m != nil && m.Connectiontype != nil {
		return *m.Connectiontype
	}
	return Default_BidRequest_Device_Connectiontype
}

func (m *BidRequest_Device) GetDevicetype() Enums_BidRequest_Device_DeviceType {
	if m != nil && m.Devicetype != nil {
		return *m.Devicetype
	}
	return Default_BidRequest_Device_Devicetype
}

func (m *BidRequest_Device) GetFlashver() string {
	if m != nil && m.Flashver != nil {
		return *m.Flashver
	}
	return ""
}

func (m *BidRequest_Device) GetLmt() bool {
	if m != nil && m.Lmt != nil {
		return *m.Lmt
	}
	return false
}

func (m *BidRequest_Device) GetHwv() string {
	if m != nil && m.Hwv != nil {
		return *m.Hwv
	}
	return ""
}

func (m *BidRequest_Device) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *BidRequest_Device) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *BidRequest_Device) GetPpi() int32 {
	if m != nil && m.Ppi != nil {
		return *m.Ppi
	}
	return 0
}

func (m *BidRequest_Device) GetPxratio() float64 {
	if m != nil && m.Pxratio != nil {
		return *m.Pxratio
	}
	return 0
}

func (m *BidRequest_Device) GetIfa() string {
	if m != nil && m.Ifa != nil {
		return *m.Ifa
	}
	return ""
}

func (m *BidRequest_Device) GetMacsha1() string {
	if m != nil && m.Macsha1 != nil {
		return *m.Macsha1
	}
	return ""
}

func (m *BidRequest_Device) GetMacmd5() string {
	if m != nil && m.Macmd5 != nil {
		return *m.Macmd5
	}
	return ""
}

func (m *BidRequest_Device) GetMccmnc() string {
	if m != nil && m.Mccmnc != nil {
		return *m.Mccmnc
	}
	return ""
}

func (m *BidRequest_Device) GetExt() *DeviceExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.12: contains information known or derived about the human user of the device.
// Note that the user ID is an exchange artifact (refer to the “device” object for hardware or
// platform derived IDs) and may be subject to rotation policies. However, this user ID must be
// stable long enough to serve reasonably as the basis for frequency capping.
// If device ID is used as a proxy for unique user ID, use the device object.
type BidRequest_User struct {
	//
	// Unique consumer ID of this user on the exchange.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Buyer’s user ID for this user as mapped by exchange for the buyer.
	Buyeruid *string `protobuf:"bytes,2,opt,name=buyeruid" json:"buyeruid,omitempty"`
	//
	// Year of birth as a 4-digit integer.
	Yob *int32 `protobuf:"varint,3,opt,name=yob" json:"yob,omitempty"`
	//
	// Gender as “M” male, “F” female, “O” Other. (Null indicates unknown)
	Gender *string `protobuf:"bytes,4,opt,name=gender" json:"gender,omitempty"`
	//
	// Comma separated list of keywords of consumer interests or intent.
	Keywords *string `protobuf:"bytes,5,opt,name=keywords" json:"keywords,omitempty"`
	//
	// If supported by the exchange, this is custom data that the bidder had stored in the
	// exchange’s cookie. The string may be in base85 cookie safe characters, and be in any
	// format. This may useful for storing user features. Note: Proper JSON encoding must
	// be used to include “escaped” quotation marks.
	Customdata *string `protobuf:"bytes,6,opt,name=customdata" json:"customdata,omitempty"`
	//
	// Home geo for the user (e.g., based off of registration data); this is different from the
	// current location of the access device (that is defined by the geo object embedded in the
	// Device Object).
	Geo *BidRequest_Geo `protobuf:"bytes,7,opt,name=geo" json:"geo,omitempty"`
	//
	// User's custom Data.
	Data             []*BidRequest_Data `protobuf:"bytes,8,rep,name=data" json:"data,omitempty"`
	Ext              *UserExtensions    `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *BidRequest_User) Reset()                    { *m = BidRequest_User{} }
func (m *BidRequest_User) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_User) ProtoMessage()               {}
func (*BidRequest_User) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 6} }

func (m *BidRequest_User) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_User) GetBuyeruid() string {
	if m != nil && m.Buyeruid != nil {
		return *m.Buyeruid
	}
	return ""
}

func (m *BidRequest_User) GetYob() int32 {
	if m != nil && m.Yob != nil {
		return *m.Yob
	}
	return 0
}

func (m *BidRequest_User) GetGender() string {
	if m != nil && m.Gender != nil {
		return *m.Gender
	}
	return ""
}

func (m *BidRequest_User) GetKeywords() string {
	if m != nil && m.Keywords != nil {
		return *m.Keywords
	}
	return ""
}

func (m *BidRequest_User) GetCustomdata() string {
	if m != nil && m.Customdata != nil {
		return *m.Customdata
	}
	return ""
}

func (m *BidRequest_User) GetGeo() *BidRequest_Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *BidRequest_User) GetData() []*BidRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BidRequest_User) GetExt() *UserExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.8: describes the publisher of a site or app.
type BidRequest_Publisher struct {
	//
	// Publisher ID on the exchange.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Publisher name (may be masked at publisher’s request).
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	//
	// Array of IAB content categories for the publisher.
	Cat []string `protobuf:"bytes,3,rep,name=cat" json:"cat,omitempty"`
	//
	// Publisher’s highest level domain name, for example “foopub.com”.
	Domain           *string              `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	Ext              *PublisherExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *BidRequest_Publisher) Reset()                    { *m = BidRequest_Publisher{} }
func (m *BidRequest_Publisher) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Publisher) ProtoMessage()               {}
func (*BidRequest_Publisher) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 7} }

func (m *BidRequest_Publisher) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Publisher) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BidRequest_Publisher) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidRequest_Publisher) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *BidRequest_Publisher) GetExt() *PublisherExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.9: describes the producer of content object, which might be different from the
// publisher of the content of the page. This object is useful in the case of syndicated content,
// such as embedded videos, for example.
type BidRequest_Producer struct {
	//
	// Content producer or originator ID. Useful if content is syndicated,
	// and may be posted on a site using embed tags.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Content producer or originator name (e.g., “Warner Bros”).
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	//
	// Array of IAB content categories for the content producer.
	Cat []string `protobuf:"bytes,3,rep,name=cat" json:"cat,omitempty"`
	//
	// URL of the content producer.
	Domain           *string             `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	Ext              *ProducerExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *BidRequest_Producer) Reset()                    { *m = BidRequest_Producer{} }
func (m *BidRequest_Producer) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Producer) ProtoMessage()               {}
func (*BidRequest_Producer) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 8} }

func (m *BidRequest_Producer) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Producer) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BidRequest_Producer) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidRequest_Producer) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *BidRequest_Producer) GetExt() *ProducerExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.11: describes the current geographic location of the Device (e.g., based on IP
// address or GPS), or the home geo of the User (e.g., based on registration data).
// If both the Device and User objects contain Geo objects with different information,
// it’s up to the bidder to determine which Geo information to use.
type BidRequest_Geo struct {
	//
	// Latitude from -90 to 90. South is negative. This should only be passed if known
	// to be accurate (For example, not the centroid of a postal code).
	Lat *float64 `protobuf:"fixed64,1,opt,name=lat" json:"lat,omitempty"`
	//
	// Longitude from -180 to 180. West is negative. This should only be passed if known
	// to be accurate (For example, not the centroid of a postal code).
	Lon *float64 `protobuf:"fixed64,2,opt,name=lon" json:"lon,omitempty"`
	//
	// Country using ISO-3166-1 Alpha-3.
	Country *string `protobuf:"bytes,3,opt,name=country" json:"country,omitempty"`
	//
	// Region using ISO 3166-2
	Region *string `protobuf:"bytes,4,opt,name=region" json:"region,omitempty"`
	//
	// Region of a country using fips 10-4 notation (alternative to ISO 3166-2).
	Regionfips104 *string `protobuf:"bytes,5,opt,name=regionfips104" json:"regionfips104,omitempty"`
	//
	// Pass the metro code (see http://code.google.com/apis/adwords/docs/appendix/metrocodes.html).
	// Metro codes are similar to but not exactly the same as Nielsen DMAs.
	Metro *string `protobuf:"bytes,6,opt,name=metro" json:"metro,omitempty"`
	//
	// City using United Nations Code for Trade and Transport Locations
	// (http://www.unece.org/cefact/locode/service/location.htm).
	City *string `protobuf:"bytes,7,opt,name=city" json:"city,omitempty"`
	//
	// Zip/postal code.
	Zip *string `protobuf:"bytes,8,opt,name=zip" json:"zip,omitempty"`
	//
	// Indicate the source of the geo data (GPS, IP address, user provided).
	// Type should be provided when lat/lon is provided.
	Type *Enums_BidRequest_Geo_LocationType `protobuf:"varint,9,opt,name=type,enum=openrtb.Enums_BidRequest_Geo_LocationType" json:"type,omitempty"`
	//
	// Local time as the number +/- of minutes from UTC.
	Utcoffset        *int32         `protobuf:"varint,10,opt,name=utcoffset" json:"utcoffset,omitempty"`
	Ext              *GeoExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *BidRequest_Geo) Reset()                    { *m = BidRequest_Geo{} }
func (m *BidRequest_Geo) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Geo) ProtoMessage()               {}
func (*BidRequest_Geo) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 9} }

func (m *BidRequest_Geo) GetLat() float64 {
	if m != nil && m.Lat != nil {
		return *m.Lat
	}
	return 0
}

func (m *BidRequest_Geo) GetLon() float64 {
	if m != nil && m.Lon != nil {
		return *m.Lon
	}
	return 0
}

func (m *BidRequest_Geo) GetCountry() string {
	if m != nil && m.Country != nil {
		return *m.Country
	}
	return ""
}

func (m *BidRequest_Geo) GetRegion() string {
	if m != nil && m.Region != nil {
		return *m.Region
	}
	return ""
}

func (m *BidRequest_Geo) GetRegionfips104() string {
	if m != nil && m.Regionfips104 != nil {
		return *m.Regionfips104
	}
	return ""
}

func (m *BidRequest_Geo) GetMetro() string {
	if m != nil && m.Metro != nil {
		return *m.Metro
	}
	return ""
}

func (m *BidRequest_Geo) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *BidRequest_Geo) GetZip() string {
	if m != nil && m.Zip != nil {
		return *m.Zip
	}
	return ""
}

func (m *BidRequest_Geo) GetType() Enums_BidRequest_Geo_LocationType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Enums_BidRequest_Geo_GPS_LOCATION
}

func (m *BidRequest_Geo) GetUtcoffset() int32 {
	if m != nil && m.Utcoffset != nil {
		return *m.Utcoffset
	}
	return 0
}

func (m *BidRequest_Geo) GetExt() *GeoExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.13: The data and segment objects together allow data about the user to be passed
// to bidders in the bid request. This data may be from multiple sources (e.g., the exchange
// itself, third party providers) as specified by the data object ID field.
// A bid request can mix data objects from multiple providers.
type BidRequest_Data struct {
	//
	// Exchange specific ID for the data provider.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Data provider name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	//
	// Array of segment objects.
	Segment          []*BidRequest_Data_Segment `protobuf:"bytes,3,rep,name=segment" json:"segment,omitempty"`
	Ext              *DataExtensions            `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *BidRequest_Data) Reset()                    { *m = BidRequest_Data{} }
func (m *BidRequest_Data) String() string            { return proto.CompactTextString(m) }
func (*BidRequest_Data) ProtoMessage()               {}
func (*BidRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{0, 10} }

func (m *BidRequest_Data) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Data) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BidRequest_Data) GetSegment() []*BidRequest_Data_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *BidRequest_Data) GetExt() *DataExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.14: convey specific units of information from the provider identified
// in the parent data object.
type BidRequest_Data_Segment struct {
	//
	// ID of a data provider’s segment applicable to the user.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Name of a data provider’s segment applicable to the user.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	//
	// String representing the value of the segment. The method for transmitting this data
	// should be negotiated offline with the data provider.
	// For example for gender, “male”, or “female”, for age, “30-40”).
	Value            *string            `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Ext              *SegmentExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *BidRequest_Data_Segment) Reset()         { *m = BidRequest_Data_Segment{} }
func (m *BidRequest_Data_Segment) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Data_Segment) ProtoMessage()    {}
func (*BidRequest_Data_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 10, 0}
}

func (m *BidRequest_Data_Segment) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidRequest_Data_Segment) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BidRequest_Data_Segment) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *BidRequest_Data_Segment) GetExt() *SegmentExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 3.3.15: Legal, governmental, or industry regulations that apply to the request.
type BidRequest_Regulations struct {
	//
	// Indicated wether or not this request falls under the COPPA regulations
	// established by the USA FTC.
	Coppa            *Flag                  `protobuf:"varint,1,opt,name=coppa,enum=openrtb.Flag" json:"coppa,omitempty"`
	Ext              *RegulationsExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *BidRequest_Regulations) Reset()         { *m = BidRequest_Regulations{} }
func (m *BidRequest_Regulations) String() string { return proto.CompactTextString(m) }
func (*BidRequest_Regulations) ProtoMessage()    {}
func (*BidRequest_Regulations) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{0, 11}
}

func (m *BidRequest_Regulations) GetCoppa() Flag {
	if m != nil && m.Coppa != nil {
		return *m.Coppa
	}
	return Flag_NO
}

func (m *BidRequest_Regulations) GetExt() *RegulationsExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 4.3.1: top-level bid response object.
type BidResponse struct {
	//
	// ID of the bid request.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//
	// Array of seatbid objects.
	Seatbid []*BidResponse_SeatBid `protobuf:"bytes,2,rep,name=seatbid" json:"seatbid,omitempty"`
	//
	// Bid response ID to assist tracking for bidders.
	// This value is chosen by the bidder for cross-reference.
	Bidid *string `protobuf:"bytes,3,opt,name=bidid" json:"bidid,omitempty"`
	//
	// Bid currency using ISO-4217 alphabetic codes.
	Cur *string `protobuf:"bytes,4,opt,name=cur,def=USD" json:"cur,omitempty"`
	//
	// This is an optional feature, which allows a bidder to set data in the exchange’s cookie.
	// The string may be in base85 cookie safe characters, and be in any format.
	// This may be useful for storing user features.
	// Note: Proper JSON encoding must be used to include “escaped” quotation marks.
	Customdata *string `protobuf:"bytes,5,opt,name=customdata" json:"customdata,omitempty"`
	//
	// Reason for not bidding.
	Nbr              *Enums_BidResponse_NoBidReason `protobuf:"varint,6,opt,name=nbr,enum=openrtb.Enums_BidResponse_NoBidReason" json:"nbr,omitempty"`
	Ext              *BidResponseExtensions         `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *BidResponse) Reset()                    { *m = BidResponse{} }
func (m *BidResponse) String() string            { return proto.CompactTextString(m) }
func (*BidResponse) ProtoMessage()               {}
func (*BidResponse) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{1} }

const Default_BidResponse_Cur string = "USD"

func (m *BidResponse) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidResponse) GetSeatbid() []*BidResponse_SeatBid {
	if m != nil {
		return m.Seatbid
	}
	return nil
}

func (m *BidResponse) GetBidid() string {
	if m != nil && m.Bidid != nil {
		return *m.Bidid
	}
	return ""
}

func (m *BidResponse) GetCur() string {
	if m != nil && m.Cur != nil {
		return *m.Cur
	}
	return Default_BidResponse_Cur
}

func (m *BidResponse) GetCustomdata() string {
	if m != nil && m.Customdata != nil {
		return *m.Customdata
	}
	return ""
}

func (m *BidResponse) GetNbr() Enums_BidResponse_NoBidReason {
	if m != nil && m.Nbr != nil {
		return *m.Nbr
	}
	return Enums_BidResponse_UNKNOWN_ERROR
}

func (m *BidResponse) GetExt() *BidResponseExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 4.3.2: A bid response can contain multiple “seatbid” objects, each on behalf of a
// different bidder seat. Since a bid request can include multiple impressions, each “seatbid”
// object can contain multiple bids each pertaining to a different impression on behalf of a seat.
// Thus, each “bid” object must include the impression ID to which it pertains as well as
// the bid price. The “group” attribute can be used to specify if a seat is willing to accept
// any impressions that it can win (default) or if it is only interested in winning any if it
// can win them all (i.e., all or nothing).
type BidResponse_SeatBid struct {
	//
	// Array of bid objects; each bid object relates to an imp object in the bid request.
	// Note that, if supported by an exchange, one imp object can have many bid objects.
	Bid []*BidResponse_SeatBid_Bid `protobuf:"bytes,1,rep,name=bid" json:"bid,omitempty"`
	//
	// ID of the bidder seat on whose behalf this bid is made.
	Seat *string `protobuf:"bytes,2,opt,name=seat" json:"seat,omitempty"`
	//
	// Should impressions be won or lost as a group?
	Group            *Flag              `protobuf:"varint,3,opt,name=group,enum=openrtb.Flag" json:"group,omitempty"`
	Ext              *SeatBidExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *BidResponse_SeatBid) Reset()                    { *m = BidResponse_SeatBid{} }
func (m *BidResponse_SeatBid) String() string            { return proto.CompactTextString(m) }
func (*BidResponse_SeatBid) ProtoMessage()               {}
func (*BidResponse_SeatBid) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{1, 0} }

func (m *BidResponse_SeatBid) GetBid() []*BidResponse_SeatBid_Bid {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *BidResponse_SeatBid) GetSeat() string {
	if m != nil && m.Seat != nil {
		return *m.Seat
	}
	return ""
}

func (m *BidResponse_SeatBid) GetGroup() Flag {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Flag_NO
}

func (m *BidResponse_SeatBid) GetExt() *SeatBidExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

//
// OpenRTB 4.3.3: For each bid, the “nurl” attribute contains the win notice URL.
// If the bidder wins the impression, the exchange calls this notice URL a) to inform the bidder
// of the win and b) to convey certain information using substitution macros
// (see Section 4.6 Substitution Macros). The “adomain” attribute can be used to check
// advertiser block list compliance. The “iurl” attribute can provide a link to an image that
// is representative of the campaign’s content (irrespective of whether the campaign may have
// multiple creatives). This enables human review for spotting inappropriate content.
// The “cid” attribute can be used to block ads that were previously identified as
// inappropriate; essentially a safety net beyond the block lists.  The “crid” attribute
// can be helpful in reporting creative issues back to bidders. Finally, the “attr” array
// indicates the creative attributes that describe the ad to be served.
type BidResponse_SeatBid_Bid struct {
	//
	// ID for the bid object chosen by the bidder for tracking and debugging purposes.
	// Useful when multiple bids are submitted for a single impression for a given seat.
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	//
	// ID of the impression object to which this bid applies.
	Impid *string `protobuf:"bytes,2,req,name=impid" json:"impid,omitempty"`
	//
	// Bid price in CPM. WARNING/Best Practice Note: Although this value is a float,
	// OpenRTB strongly suggests using integer math for accounting to avoid rounding errors.
	Price *float64 `protobuf:"fixed64,3,req,name=price" json:"price,omitempty"`
	//
	// ID that references the ad to be served if the bid wins.
	Adid *string `protobuf:"bytes,4,opt,name=adid" json:"adid,omitempty"`
	//
	// Win notice URL. Note that ad markup is also typically, but not necessarily,
	// returned via this URL.
	Nurl *string `protobuf:"bytes,5,opt,name=nurl" json:"nurl,omitempty"`
	//
	// Actual ad markup. XHTML if a response to a banner object,
	// or VAST XML if a response to a video object.
	// <p>
	// Open Bidder macros are supported for this field.
	Adm *string `protobuf:"bytes,6,opt,name=adm" json:"adm,omitempty"`
	//
	// Native ad response.
	// You can only set one of adm and adm_native; either will generate the "adm" field in JSON.
	AdmNative *NativeResponse `protobuf:"bytes,50,opt,name=adm_native,json=admNative" json:"adm_native,omitempty"`
	//
	// Advertiser’s primary or top-level domain for advertiser checking.
	// This can be a list of domains if there is a rotating creative.
	// However, exchanges may mandate that only one landing domain is allowed.
	Adomain []string `protobuf:"bytes,7,rep,name=adomain" json:"adomain,omitempty"`
	// *
	// Bundle or package name (e.g., com.foo.mygame) of the app being advertised, if applicable;
	// intended to be a unique ID across exchanges.
	Bundle *string `protobuf:"bytes,15,opt,name=bundle" json:"bundle,omitempty"`
	//
	// Sample image URL (without cache busting) for content checking.
	Iurl *string `protobuf:"bytes,8,opt,name=iurl" json:"iurl,omitempty"`
	//
	// Campaign ID or similar that appears within the ad markup.
	Cid *string `protobuf:"bytes,9,opt,name=cid" json:"cid,omitempty"`
	//
	// Creative ID for reporting content issues or defects.
	// This could also be used as a reference to a creative ID that is posted with an exchange.
	// <p>
	// Open Bidder macros are supported for this field.
	Crid *string `protobuf:"bytes,10,opt,name=crid" json:"crid,omitempty"`
	// *
	// IAB content category of the creative.
	Cat []string `protobuf:"bytes,16,rep,name=cat" json:"cat,omitempty"`
	//
	// Array of creative attributes.
	Attr []CreativeAttribute `protobuf:"varint,11,rep,name=attr,enum=openrtb.CreativeAttribute" json:"attr,omitempty"`
	//
	// A unique identifier for the direct deal associated with the bid.
	Dealid *string `protobuf:"bytes,12,opt,name=dealid" json:"dealid,omitempty"`
	// *
	// Width of the ad in pixels. If the bid request contained the wmax/hmax and wmin/hmin
	// optional fields it is recommended that the response bid contains this field to signal
	// the size of ad chosen.
	W *int32 `protobuf:"varint,13,opt,name=w" json:"w,omitempty"`
	// *
	// Height of the ad in pixels. If the bid request contained the wmax/hmax and wmin/hmin
	// optional fields it is recommended that the response bid contains this field to signal
	// the size of ad chosen.
	H                *int32         `protobuf:"varint,14,opt,name=h" json:"h,omitempty"`
	Ext              *BidExtensions `protobuf:"bytes,1000,opt,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *BidResponse_SeatBid_Bid) Reset()         { *m = BidResponse_SeatBid_Bid{} }
func (m *BidResponse_SeatBid_Bid) String() string { return proto.CompactTextString(m) }
func (*BidResponse_SeatBid_Bid) ProtoMessage()    {}
func (*BidResponse_SeatBid_Bid) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{1, 0, 0}
}

func (m *BidResponse_SeatBid_Bid) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetImpid() string {
	if m != nil && m.Impid != nil {
		return *m.Impid
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetPrice() float64 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *BidResponse_SeatBid_Bid) GetAdid() string {
	if m != nil && m.Adid != nil {
		return *m.Adid
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetNurl() string {
	if m != nil && m.Nurl != nil {
		return *m.Nurl
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetAdm() string {
	if m != nil && m.Adm != nil {
		return *m.Adm
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetAdmNative() *NativeResponse {
	if m != nil {
		return m.AdmNative
	}
	return nil
}

func (m *BidResponse_SeatBid_Bid) GetAdomain() []string {
	if m != nil {
		return m.Adomain
	}
	return nil
}

func (m *BidResponse_SeatBid_Bid) GetBundle() string {
	if m != nil && m.Bundle != nil {
		return *m.Bundle
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetIurl() string {
	if m != nil && m.Iurl != nil {
		return *m.Iurl
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetCid() string {
	if m != nil && m.Cid != nil {
		return *m.Cid
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetCrid() string {
	if m != nil && m.Crid != nil {
		return *m.Crid
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetCat() []string {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *BidResponse_SeatBid_Bid) GetAttr() []CreativeAttribute {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *BidResponse_SeatBid_Bid) GetDealid() string {
	if m != nil && m.Dealid != nil {
		return *m.Dealid
	}
	return ""
}

func (m *BidResponse_SeatBid_Bid) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *BidResponse_SeatBid_Bid) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *BidResponse_SeatBid_Bid) GetExt() *BidExtensions {
	if m != nil {
		return m.Ext
	}
	return nil
}

// *
// OpenRTB Native 4.1: The Native Object defines the native advertising opportunity
// available for bid via this bid request. It must be included directly in the
// impression object if the impression offered for auction is a native ad format.
type NativeRequest struct {
	// *
	// Version of the Native Markup version in use.
	Ver *string `protobuf:"bytes,1,opt,name=ver" json:"ver,omitempty"`
	// *
	// The Layout ID of the native ad unit.
	// This field is not required, but it's highly recommended.
	Layout *Enums_BidRequest_Impression_NativeRequest_LayoutId `protobuf:"varint,2,opt,name=layout,enum=openrtb.Enums_BidRequest_Impression_NativeRequest_LayoutId" json:"layout,omitempty"`
	// *
	// The Ad unit ID of the native ad unit. This corresponds to one of IAB Core-6 native ad units.
	// This field is not required, but it's highly recommended.
	Adunit *Enums_BidRequest_Impression_NativeRequest_AdUnitId `protobuf:"varint,3,opt,name=adunit,enum=openrtb.Enums_BidRequest_Impression_NativeRequest_AdUnitId" json:"adunit,omitempty"`
	// *
	// The number of identical placements in this Layout.
	Plcmtcnt *int32 `protobuf:"varint,4,opt,name=plcmtcnt,def=1" json:"plcmtcnt,omitempty"`
	// *
	// 0 for the first ad, 1 for the second ad, and so on.
	// This is not the sequence number of the content in the stream.
	Seq *int32 `protobuf:"varint,5,opt,name=seq,def=0" json:"seq,omitempty"`
	// *
	// Any bid must comply with the array of elements expressed by the Exchange.
	Assets []*NativeRequest_Asset `protobuf:"bytes,6,rep,name=assets" json:"assets,omitempty"`
	// *
	// The context in which the ad appears.
	Context *Enums_BidRequest_Impression_NativeRequest_Context `protobuf:"varint,7,opt,name=context,enum=openrtb.Enums_BidRequest_Impression_NativeRequest_Context" json:"context,omitempty"`
	// *
	// A more detailed context in which the ad appears.
	Contextsubtype *Enums_BidRequest_Impression_NativeRequest_ContextSubtype `protobuf:"varint,8,opt,name=contextsubtype,enum=openrtb.Enums_BidRequest_Impression_NativeRequest_ContextSubtype" json:"contextsubtype,omitempty"`
	// *
	// The design/format/layout of the ad unit being offered.
	Plcmttype                    *Enums_BidRequest_Impression_NativeRequest_PlacementType `protobuf:"varint,9,opt,name=plcmttype,enum=openrtb.Enums_BidRequest_Impression_NativeRequest_PlacementType" json:"plcmttype,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeRequest) Reset()                    { *m = NativeRequest{} }
func (m *NativeRequest) String() string            { return proto.CompactTextString(m) }
func (*NativeRequest) ProtoMessage()               {}
func (*NativeRequest) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{2} }

var extRange_NativeRequest = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeRequest) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeRequest
}

const Default_NativeRequest_Plcmtcnt int32 = 1
const Default_NativeRequest_Seq int32 = 0

func (m *NativeRequest) GetVer() string {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return ""
}

func (m *NativeRequest) GetLayout() Enums_BidRequest_Impression_NativeRequest_LayoutId {
	if m != nil && m.Layout != nil {
		return *m.Layout
	}
	return Enums_BidRequest_Impression_NativeRequest_CONTENT_WALL
}

func (m *NativeRequest) GetAdunit() Enums_BidRequest_Impression_NativeRequest_AdUnitId {
	if m != nil && m.Adunit != nil {
		return *m.Adunit
	}
	return Enums_BidRequest_Impression_NativeRequest_PAID_SEARCH_UNIT
}

func (m *NativeRequest) GetPlcmtcnt() int32 {
	if m != nil && m.Plcmtcnt != nil {
		return *m.Plcmtcnt
	}
	return Default_NativeRequest_Plcmtcnt
}

func (m *NativeRequest) GetSeq() int32 {
	if m != nil && m.Seq != nil {
		return *m.Seq
	}
	return Default_NativeRequest_Seq
}

func (m *NativeRequest) GetAssets() []*NativeRequest_Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *NativeRequest) GetContext() Enums_BidRequest_Impression_NativeRequest_Context {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return Enums_BidRequest_Impression_NativeRequest_CONTENT_CENTRIC
}

func (m *NativeRequest) GetContextsubtype() Enums_BidRequest_Impression_NativeRequest_ContextSubtype {
	if m != nil && m.Contextsubtype != nil {
		return *m.Contextsubtype
	}
	return Enums_BidRequest_Impression_NativeRequest_GENERAL_OR_MIXED
}

func (m *NativeRequest) GetPlcmttype() Enums_BidRequest_Impression_NativeRequest_PlacementType {
	if m != nil && m.Plcmttype != nil {
		return *m.Plcmttype
	}
	return Enums_BidRequest_Impression_NativeRequest_FEED
}

// *
// OpenRTB Native 4.2: The main container object for each asset requested or supported by
// Exchange on behalf of the rendering client. Any object that is required
// is to be flagged as such. Only one of the {title,img,video,data} objects should be
// present in each object. All others should be null/absent. The id is to be unique within
// the Asset array so that the response can be aligned.
type NativeRequest_Asset struct {
	// *
	// Unique asset ID, assigned by exchange. Typically a counter for the array.
	Id *int32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// *
	// Set to true if asset is required (exchange will not accept a bid without it).
	Required *bool `protobuf:"varint,2,opt,name=required,def=0" json:"required,omitempty"`
	// *
	// Title object for title assets.
	Title *NativeRequest_Asset_Title `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	// *
	// Image object for image assets.
	Img *NativeRequest_Asset_Image `protobuf:"bytes,4,opt,name=img" json:"img,omitempty"`
	// *
	// Video object for video assets.
	// Note that in-stream video ads are not part of Native.  Native ads may contain a video
	// as the ad creative itself.
	Video *BidRequest_Impression_Video `protobuf:"bytes,5,opt,name=video" json:"video,omitempty"`
	// *
	// Data object for ratings, prices etc.
	Data                         *NativeRequest_Asset_Data `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeRequest_Asset) Reset()                    { *m = NativeRequest_Asset{} }
func (m *NativeRequest_Asset) String() string            { return proto.CompactTextString(m) }
func (*NativeRequest_Asset) ProtoMessage()               {}
func (*NativeRequest_Asset) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{2, 0} }

var extRange_NativeRequest_Asset = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeRequest_Asset) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeRequest_Asset
}

const Default_NativeRequest_Asset_Required bool = false

func (m *NativeRequest_Asset) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *NativeRequest_Asset) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return Default_NativeRequest_Asset_Required
}

func (m *NativeRequest_Asset) GetTitle() *NativeRequest_Asset_Title {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *NativeRequest_Asset) GetImg() *NativeRequest_Asset_Image {
	if m != nil {
		return m.Img
	}
	return nil
}

func (m *NativeRequest_Asset) GetVideo() *BidRequest_Impression_Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *NativeRequest_Asset) GetData() *NativeRequest_Asset_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// OpenRTB Native 4.3: The Title object is to be used for title element of the Native ad.
type NativeRequest_Asset_Title struct {
	// *
	// Maximum length of the text in the title element.
	Len                          *int32 `protobuf:"varint,1,req,name=len" json:"len,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeRequest_Asset_Title) Reset()         { *m = NativeRequest_Asset_Title{} }
func (m *NativeRequest_Asset_Title) String() string { return proto.CompactTextString(m) }
func (*NativeRequest_Asset_Title) ProtoMessage()    {}
func (*NativeRequest_Asset_Title) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{2, 0, 0}
}

var extRange_NativeRequest_Asset_Title = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeRequest_Asset_Title) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeRequest_Asset_Title
}

func (m *NativeRequest_Asset_Title) GetLen() int32 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

// *
// OpenRTB Native 4.4: The Image object to be used for all image elements of the
// Native ad such as Icons, Main Image, etc.
type NativeRequest_Asset_Image struct {
	// *
	// Type ID of the image element supported by the publisher.
	// The publisher can display this information in an appropriate format.
	Type *NativeRequest_Asset_Image_ImageAssetType `protobuf:"varint,1,opt,name=type,enum=openrtb.NativeRequest_Asset_Image_ImageAssetType" json:"type,omitempty"`
	// *
	// Width of the image in pixels.
	W *int32 `protobuf:"varint,2,opt,name=w" json:"w,omitempty"`
	// *
	// Height of the image in pixels.
	H *int32 `protobuf:"varint,3,opt,name=h" json:"h,omitempty"`
	// *
	// The minimum requested width of the image in pixels. This option should be used for any
	// rescaling of images by the client. Either w or wmin should be transmitted.
	// If only w is included, it should be considered an exact requirement.
	Wmin *int32 `protobuf:"varint,4,opt,name=wmin" json:"wmin,omitempty"`
	// *
	// The minimum requested height of the image in pixels. This option should be used for any
	// rescaling of images by the client. Either h or hmin should be transmitted.
	// If only h is included, it should be considered an exact requirement.
	Hmin *int32 `protobuf:"varint,5,opt,name=hmin" json:"hmin,omitempty"`
	// *
	// Whitelist of content MIME types supported. Popular MIME types include, but are not
	// limited to "image/jpg" and "image/gif". Each implementing Exchange should have their
	// own list of supported types in the integration docs. See Wikipedia's MIME page for
	// more information and links to all IETF RFCs. If blank, assume all types are allowed.
	Mimes                        []string `protobuf:"bytes,6,rep,name=mimes" json:"mimes,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeRequest_Asset_Image) Reset()         { *m = NativeRequest_Asset_Image{} }
func (m *NativeRequest_Asset_Image) String() string { return proto.CompactTextString(m) }
func (*NativeRequest_Asset_Image) ProtoMessage()    {}
func (*NativeRequest_Asset_Image) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{2, 0, 1}
}

var extRange_NativeRequest_Asset_Image = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeRequest_Asset_Image) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeRequest_Asset_Image
}

func (m *NativeRequest_Asset_Image) GetType() NativeRequest_Asset_Image_ImageAssetType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NativeRequest_Asset_Image_ICON
}

func (m *NativeRequest_Asset_Image) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *NativeRequest_Asset_Image) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

func (m *NativeRequest_Asset_Image) GetWmin() int32 {
	if m != nil && m.Wmin != nil {
		return *m.Wmin
	}
	return 0
}

func (m *NativeRequest_Asset_Image) GetHmin() int32 {
	if m != nil && m.Hmin != nil {
		return *m.Hmin
	}
	return 0
}

func (m *NativeRequest_Asset_Image) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

// *
// OpenRT Native 4.6: The Data Object is to be used for all non-core elements of the
// native unit such as Ratings, Review Count, Stars, Download count, descriptions etc.
// It is also generic for future of Native elements not contemplated at the time of the
// writing of this document.
type NativeRequest_Asset_Data struct {
	// *
	// Type ID of the element supported by the publisher. The publisher can display this
	// information in an appropriate format.
	Type *NativeRequest_Asset_Data_DataAssetType `protobuf:"varint,1,opt,name=type,enum=openrtb.NativeRequest_Asset_Data_DataAssetType" json:"type,omitempty"`
	// *
	// Maximum length of the text in the element's response.
	Len                          *int32 `protobuf:"varint,2,opt,name=len" json:"len,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeRequest_Asset_Data) Reset()         { *m = NativeRequest_Asset_Data{} }
func (m *NativeRequest_Asset_Data) String() string { return proto.CompactTextString(m) }
func (*NativeRequest_Asset_Data) ProtoMessage()    {}
func (*NativeRequest_Asset_Data) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{2, 0, 2}
}

var extRange_NativeRequest_Asset_Data = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeRequest_Asset_Data) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeRequest_Asset_Data
}

func (m *NativeRequest_Asset_Data) GetType() NativeRequest_Asset_Data_DataAssetType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NativeRequest_Asset_Data_SPONSORED
}

func (m *NativeRequest_Asset_Data) GetLen() int32 {
	if m != nil && m.Len != nil {
		return *m.Len
	}
	return 0
}

// *
// OpenRTB Native 5.2: The native response object is the top level JSON object which identifies
// an native response.
type NativeResponse struct {
	// *
	// Version of the Native Markup version in use.
	Ver *string `protobuf:"bytes,1,opt,name=ver" json:"ver,omitempty"`
	// *
	// List of native ad's assets.
	Assets []*NativeResponse_Asset `protobuf:"bytes,2,rep,name=assets" json:"assets,omitempty"`
	// *
	// Destination Link.
	Link *NativeResponse_Link `protobuf:"bytes,3,req,name=link" json:"link,omitempty"`
	// *
	// Array of impression tracking URLs, expected to return a 1x1 image or 204 response -
	// typically only passed when using 3rd party trackers.
	Imptrackers []string `protobuf:"bytes,4,rep,name=imptrackers" json:"imptrackers,omitempty"`
	// *
	// Optional javascript impression tracker. Contains <script> tags to be executed at
	// impression time where it can be supported.
	Jstracker                    *string `protobuf:"bytes,5,opt,name=jstracker" json:"jstracker,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse) Reset()                    { *m = NativeResponse{} }
func (m *NativeResponse) String() string            { return proto.CompactTextString(m) }
func (*NativeResponse) ProtoMessage()               {}
func (*NativeResponse) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{3} }

var extRange_NativeResponse = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse
}

func (m *NativeResponse) GetVer() string {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return ""
}

func (m *NativeResponse) GetAssets() []*NativeResponse_Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *NativeResponse) GetLink() *NativeResponse_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *NativeResponse) GetImptrackers() []string {
	if m != nil {
		return m.Imptrackers
	}
	return nil
}

func (m *NativeResponse) GetJstracker() string {
	if m != nil && m.Jstracker != nil {
		return *m.Jstracker
	}
	return ""
}

// *
// OpenRTB Native 5.8: Used for "call to action" assets, or other links from the Native ad.
// This Object should be associated to its peer object in the parent Asset Object.
// When that peer object is activated (clicked) the action should take the user to the
// location of the link.
type NativeResponse_Link struct {
	// *
	// Landing URL of the clickable link.
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// *
	// List of third-party tracker URLs to be fired on click of the URL.
	Clicktrackers []string `protobuf:"bytes,2,rep,name=clicktrackers" json:"clicktrackers,omitempty"`
	// *
	// Fallback URL for deeplink. To be used if the URL given in url is not supported by the device.
	Fallback                     *string `protobuf:"bytes,3,opt,name=fallback" json:"fallback,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Link) Reset()                    { *m = NativeResponse_Link{} }
func (m *NativeResponse_Link) String() string            { return proto.CompactTextString(m) }
func (*NativeResponse_Link) ProtoMessage()               {}
func (*NativeResponse_Link) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{3, 0} }

var extRange_NativeResponse_Link = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Link) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Link
}

func (m *NativeResponse_Link) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *NativeResponse_Link) GetClicktrackers() []string {
	if m != nil {
		return m.Clicktrackers
	}
	return nil
}

func (m *NativeResponse_Link) GetFallback() string {
	if m != nil && m.Fallback != nil {
		return *m.Fallback
	}
	return ""
}

// *
// OpenRTB Native 5.3: Corresponds to the Asset Object in the request.
// The main container object for each asset requested or supported by Exchange on behalf
// of the rendering client. Any object that is required is to be flagged as such.
// Only one of the {title,img,video,data} objects should be present in each object.
// All others should be null/absent. The id is to be unique within the Asset array
// so that the response can be aligned.
type NativeResponse_Asset struct {
	// *
	// Unique asset ID, assigned by exchange, must match one of the asset IDs in request.
	Id *int32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// *
	// Set to 1 if asset is required. (bidder requires it to be displayed).
	Required *bool `protobuf:"varint,2,opt,name=required,def=0" json:"required,omitempty"`
	// *
	// Title object for title assets.
	Title *NativeResponse_Asset_Title `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	// *
	// Image object for image assets.
	Img *NativeResponse_Asset_Image `protobuf:"bytes,4,opt,name=img" json:"img,omitempty"`
	// *
	// Video object for video assets.
	// Note that in-stream video ads are not part of Native. Native ads may contain a video
	// as the ad creative itself.
	Video *NativeResponse_Asset_Video `protobuf:"bytes,5,opt,name=video" json:"video,omitempty"`
	// *
	// Data object for ratings, prices etc.
	Data *NativeResponse_Asset_Data `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	// *
	// Link object for call to actions. This link is to associated to the other populated
	// field within the object.
	Link                         *NativeResponse_Link `protobuf:"bytes,7,opt,name=link" json:"link,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Asset) Reset()                    { *m = NativeResponse_Asset{} }
func (m *NativeResponse_Asset) String() string            { return proto.CompactTextString(m) }
func (*NativeResponse_Asset) ProtoMessage()               {}
func (*NativeResponse_Asset) Descriptor() ([]byte, []int) { return fileDescriptorOpenrtb, []int{3, 1} }

var extRange_NativeResponse_Asset = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Asset) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Asset
}

const Default_NativeResponse_Asset_Required bool = false

func (m *NativeResponse_Asset) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *NativeResponse_Asset) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return Default_NativeResponse_Asset_Required
}

func (m *NativeResponse_Asset) GetTitle() *NativeResponse_Asset_Title {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *NativeResponse_Asset) GetImg() *NativeResponse_Asset_Image {
	if m != nil {
		return m.Img
	}
	return nil
}

func (m *NativeResponse_Asset) GetVideo() *NativeResponse_Asset_Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *NativeResponse_Asset) GetData() *NativeResponse_Asset_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *NativeResponse_Asset) GetLink() *NativeResponse_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

// *
// OpenRTB Native 5.4: Corresponds to the Title Object in the request, with the value filled in.
type NativeResponse_Asset_Title struct {
	// *
	// The text associated with the text element.
	Text                         *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Asset_Title) Reset()         { *m = NativeResponse_Asset_Title{} }
func (m *NativeResponse_Asset_Title) String() string { return proto.CompactTextString(m) }
func (*NativeResponse_Asset_Title) ProtoMessage()    {}
func (*NativeResponse_Asset_Title) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{3, 1, 0}
}

var extRange_NativeResponse_Asset_Title = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Asset_Title) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Asset_Title
}

func (m *NativeResponse_Asset_Title) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

// *
// OpenRTB Native 5.5: Corresponds to the Image Object in the request. The Image object
// to be used for all image elements of the Native ad such as Icons, Main Image, etc.
type NativeResponse_Asset_Image struct {
	// *
	// URL of the image asset.
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// *
	// Width of the image in pixels.
	// This field is not required, but it's highly recommended.
	W *int32 `protobuf:"varint,2,opt,name=w" json:"w,omitempty"`
	// *
	// Height of the image in pixels.
	// This field is not required, but it's highly recommended.
	H                            *int32 `protobuf:"varint,3,opt,name=h" json:"h,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Asset_Image) Reset()         { *m = NativeResponse_Asset_Image{} }
func (m *NativeResponse_Asset_Image) String() string { return proto.CompactTextString(m) }
func (*NativeResponse_Asset_Image) ProtoMessage()    {}
func (*NativeResponse_Asset_Image) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{3, 1, 1}
}

var extRange_NativeResponse_Asset_Image = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Asset_Image) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Asset_Image
}

func (m *NativeResponse_Asset_Image) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *NativeResponse_Asset_Image) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *NativeResponse_Asset_Image) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

// *
// OpenRTB Native 5.6: Corresponds to the Data Object in the request, with the value filled in.
// The Data Object is to be used for all miscellaneous elements of the native unit such as
// Ratings, Review Count, Stars, Downloads, Price count etc. It is also generic for future
// of Native elements not contemplated at the time of the writing of this document.
type NativeResponse_Asset_Data struct {
	// *
	// The optional formatted string name of the data type to be displayed.
	Label *string `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	// *
	// The formatted string of data to be displayed. Can contain a formatted value such as
	// "5 stars" or "$10" or "3.4 stars out of 5".
	Value                        *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Asset_Data) Reset()         { *m = NativeResponse_Asset_Data{} }
func (m *NativeResponse_Asset_Data) String() string { return proto.CompactTextString(m) }
func (*NativeResponse_Asset_Data) ProtoMessage()    {}
func (*NativeResponse_Asset_Data) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{3, 1, 2}
}

var extRange_NativeResponse_Asset_Data = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Asset_Data) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Asset_Data
}

func (m *NativeResponse_Asset_Data) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *NativeResponse_Asset_Data) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// OpenRTB Native 5.7: Corresponds to the Video Object in the request,
// yet containing a value of a conforming VAST tag as a value.
type NativeResponse_Asset_Video struct {
	// *
	// vast xml.
	Vasttag                      []string `protobuf:"bytes,1,rep,name=vasttag" json:"vasttag,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *NativeResponse_Asset_Video) Reset()         { *m = NativeResponse_Asset_Video{} }
func (m *NativeResponse_Asset_Video) String() string { return proto.CompactTextString(m) }
func (*NativeResponse_Asset_Video) ProtoMessage()    {}
func (*NativeResponse_Asset_Video) Descriptor() ([]byte, []int) {
	return fileDescriptorOpenrtb, []int{3, 1, 3}
}

var extRange_NativeResponse_Asset_Video = []proto.ExtensionRange{
	{Start: 100, End: 9999},
}

func (*NativeResponse_Asset_Video) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_NativeResponse_Asset_Video
}

func (m *NativeResponse_Asset_Video) GetVasttag() []string {
	if m != nil {
		return m.Vasttag
	}
	return nil
}

func init() {
	proto.RegisterType((*BidRequest)(nil), "openrtb.BidRequest")
	proto.RegisterType((*BidRequest_Source)(nil), "openrtb.BidRequest.Source")
	proto.RegisterType((*BidRequest_Impression)(nil), "openrtb.BidRequest.Impression")
	proto.RegisterType((*BidRequest_Impression_Banner)(nil), "openrtb.BidRequest.Impression.Banner")
	proto.RegisterType((*BidRequest_Impression_Video)(nil), "openrtb.BidRequest.Impression.Video")
	proto.RegisterType((*BidRequest_Impression_Native)(nil), "openrtb.BidRequest.Impression.Native")
	proto.RegisterType((*BidRequest_Impression_PMP)(nil), "openrtb.BidRequest.Impression.PMP")
	proto.RegisterType((*BidRequest_Impression_PMP_DirectDeal)(nil), "openrtb.BidRequest.Impression.PMP.DirectDeal")
	proto.RegisterType((*BidRequest_Site)(nil), "openrtb.BidRequest.Site")
	proto.RegisterType((*BidRequest_App)(nil), "openrtb.BidRequest.App")
	proto.RegisterType((*BidRequest_Content)(nil), "openrtb.BidRequest.Content")
	proto.RegisterType((*BidRequest_Device)(nil), "openrtb.BidRequest.Device")
	proto.RegisterType((*BidRequest_User)(nil), "openrtb.BidRequest.User")
	proto.RegisterType((*BidRequest_Publisher)(nil), "openrtb.BidRequest.Publisher")
	proto.RegisterType((*BidRequest_Producer)(nil), "openrtb.BidRequest.Producer")
	proto.RegisterType((*BidRequest_Geo)(nil), "openrtb.BidRequest.Geo")
	proto.RegisterType((*BidRequest_Data)(nil), "openrtb.BidRequest.Data")
	proto.RegisterType((*BidRequest_Data_Segment)(nil), "openrtb.BidRequest.Data.Segment")
	proto.RegisterType((*BidRequest_Regulations)(nil), "openrtb.BidRequest.Regulations")
	proto.RegisterType((*BidResponse)(nil), "openrtb.BidResponse")
	proto.RegisterType((*BidResponse_SeatBid)(nil), "openrtb.BidResponse.SeatBid")
	proto.RegisterType((*BidResponse_SeatBid_Bid)(nil), "openrtb.BidResponse.SeatBid.Bid")
	proto.RegisterType((*NativeRequest)(nil), "openrtb.NativeRequest")
	proto.RegisterType((*NativeRequest_Asset)(nil), "openrtb.NativeRequest.Asset")
	proto.RegisterType((*NativeRequest_Asset_Title)(nil), "openrtb.NativeRequest.Asset.Title")
	proto.RegisterType((*NativeRequest_Asset_Image)(nil), "openrtb.NativeRequest.Asset.Image")
	proto.RegisterType((*NativeRequest_Asset_Data)(nil), "openrtb.NativeRequest.Asset.Data")
	proto.RegisterType((*NativeResponse)(nil), "openrtb.NativeResponse")
	proto.RegisterType((*NativeResponse_Link)(nil), "openrtb.NativeResponse.Link")
	proto.RegisterType((*NativeResponse_Asset)(nil), "openrtb.NativeResponse.Asset")
	proto.RegisterType((*NativeResponse_Asset_Title)(nil), "openrtb.NativeResponse.Asset.Title")
	proto.RegisterType((*NativeResponse_Asset_Image)(nil), "openrtb.NativeResponse.Asset.Image")
	proto.RegisterType((*NativeResponse_Asset_Data)(nil), "openrtb.NativeResponse.Asset.Data")
	proto.RegisterType((*NativeResponse_Asset_Video)(nil), "openrtb.NativeResponse.Asset.Video")
	proto.RegisterEnum("openrtb.NativeRequest_Asset_Image_ImageAssetType", NativeRequest_Asset_Image_ImageAssetType_name, NativeRequest_Asset_Image_ImageAssetType_value)
	proto.RegisterEnum("openrtb.NativeRequest_Asset_Data_DataAssetType", NativeRequest_Asset_Data_DataAssetType_name, NativeRequest_Asset_Data_DataAssetType_value)
}
func (m *BidRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if len(m.Imp) > 0 {
		for _, msg := range m.Imp {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Site != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Site.Size()))
		n1, err := m.Site.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.App != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.App.Size()))
		n2, err := m.App.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Device != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Device.Size()))
		n3, err := m.Device.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.User != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.User.Size()))
		n4, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.At != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.At))
	}
	if m.Tmax != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Tmax))
	}
	if len(m.Wseat) > 0 {
		for _, s := range m.Wseat {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Allimps != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Allimps))
	}
	if len(m.Cur) > 0 {
		for _, s := range m.Cur {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Bcat) > 0 {
		for _, s := range m.Bcat {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Badv) > 0 {
		for _, s := range m.Badv {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Regs != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Regs.Size()))
		n5, err := m.Regs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Test != nil {
		dAtA[i] = 0x78
		i++
		if *m.Test {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Source != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Source.Size()))
		n6, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n7, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fd != nil {
		dAtA[i] = 0x8
		i++
		if *m.Fd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Tid)))
		i += copy(dAtA[i:], *m.Tid)
	}
	if m.Pchain != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Pchain)))
		i += copy(dAtA[i:], *m.Pchain)
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Banner != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Banner.Size()))
		n8, err := m.Banner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Video != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Video.Size()))
		n9, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Displaymanager != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Displaymanager)))
		i += copy(dAtA[i:], *m.Displaymanager)
	}
	if m.Displaymanagerver != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Displaymanagerver)))
		i += copy(dAtA[i:], *m.Displaymanagerver)
	}
	if m.Instl != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Instl))
	}
	if m.Tagid != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Tagid)))
		i += copy(dAtA[i:], *m.Tagid)
	}
	if m.Bidfloor != nil {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Bidfloor))))
		i += 8
	}
	if m.Bidfloorcur != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Bidfloorcur)))
		i += copy(dAtA[i:], *m.Bidfloorcur)
	}
	if len(m.Iframebuster) > 0 {
		for _, s := range m.Iframebuster {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Pmp != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Pmp.Size()))
		n10, err := m.Pmp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Secure != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Secure))
	}
	if m.Native != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Native.Size()))
		n11, err := m.Native.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Exp != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Exp))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n12, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression_Banner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression_Banner) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.W != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	if m.Id != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Pos != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Pos))
	}
	if len(m.Btype) > 0 {
		for _, num := range m.Btype {
			dAtA[i] = 0x28
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if len(m.Battr) > 0 {
		for _, num := range m.Battr {
			dAtA[i] = 0x30
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Topframe != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Topframe))
	}
	if len(m.Expdir) > 0 {
		for _, num := range m.Expdir {
			dAtA[i] = 0x48
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if len(m.Api) > 0 {
		for _, num := range m.Api {
			dAtA[i] = 0x50
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.Wmax != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Wmax))
	}
	if m.Hmax != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Hmax))
	}
	if m.Wmin != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Wmin))
	}
	if m.Hmin != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Hmin))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n13, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression_Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression_Video) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Linearity != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Linearity))
	}
	if m.Minduration != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Minduration))
	}
	if m.Maxduration != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Maxduration))
	}
	if len(m.Protocols) > 0 {
		for _, num := range m.Protocols {
			dAtA[i] = 0x28
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.W != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	if m.Startdelay != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Startdelay))
	}
	if m.Sequence != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Sequence))
	}
	if len(m.Battr) > 0 {
		for _, num := range m.Battr {
			dAtA[i] = 0x50
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.Maxextended != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Maxextended))
	}
	if m.Minbitrate != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Minbitrate))
	}
	if m.Maxbitrate != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Maxbitrate))
	}
	if m.Boxingallowed != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Boxingallowed))
	}
	if len(m.Playbackmethod) > 0 {
		for _, num := range m.Playbackmethod {
			dAtA[i] = 0x78
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if len(m.Delivery) > 0 {
		for _, num := range m.Delivery {
			dAtA[i] = 0x80
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.Pos != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Pos))
	}
	if len(m.Companionad) > 0 {
		for _, msg := range m.Companionad {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Api) > 0 {
		for _, num := range m.Api {
			dAtA[i] = 0x98
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if len(m.Companiontype) > 0 {
		for _, num := range m.Companiontype {
			dAtA[i] = 0xa0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.Placement != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Placement))
	}
	if m.Playbackend != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Playbackend))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n14, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression_Native) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression_Native) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request == nil {
		return 0, proto.NewRequiredNotSetError("request")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Request.Size()))
		n15, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Ver != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ver)))
		i += copy(dAtA[i:], *m.Ver)
	}
	if len(m.Api) > 0 {
		dAtA17 := make([]byte, len(m.Api)*10)
		var j16 int
		for _, num := range m.Api {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.Battr) > 0 {
		dAtA19 := make([]byte, len(m.Battr)*10)
		var j18 int
		for _, num := range m.Battr {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n20, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression_PMP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression_PMP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrivateAuction != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.PrivateAuction))
	}
	if len(m.Deals) > 0 {
		for _, msg := range m.Deals {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n21, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Impression_PMP_DirectDeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Impression_PMP_DirectDeal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Bidfloor != nil {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Bidfloor))))
		i += 8
	}
	if m.Bidfloorcur != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Bidfloorcur)))
		i += copy(dAtA[i:], *m.Bidfloorcur)
	}
	if len(m.Wseat) > 0 {
		for _, s := range m.Wseat {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Wadomain) > 0 {
		for _, s := range m.Wadomain {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.At != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.At))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n22, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Site) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Site) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Domain != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sectioncat) > 0 {
		for _, s := range m.Sectioncat {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Pagecat) > 0 {
		for _, s := range m.Pagecat {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Page != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Page)))
		i += copy(dAtA[i:], *m.Page)
	}
	if m.Privacypolicy != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Privacypolicy))
	}
	if m.Ref != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ref)))
		i += copy(dAtA[i:], *m.Ref)
	}
	if m.Search != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Search)))
		i += copy(dAtA[i:], *m.Search)
	}
	if m.Publisher != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Publisher.Size()))
		n23, err := m.Publisher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Content != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Content.Size()))
		n24, err := m.Content.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Keywords != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Keywords)))
		i += copy(dAtA[i:], *m.Keywords)
	}
	if m.Mobile != nil {
		dAtA[i] = 0x78
		i++
		if *m.Mobile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n25, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Domain != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sectioncat) > 0 {
		for _, s := range m.Sectioncat {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Pagecat) > 0 {
		for _, s := range m.Pagecat {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Ver != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ver)))
		i += copy(dAtA[i:], *m.Ver)
	}
	if m.Bundle != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Bundle)))
		i += copy(dAtA[i:], *m.Bundle)
	}
	if m.Privacypolicy != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Privacypolicy))
	}
	if m.Paid != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Paid))
	}
	if m.Publisher != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Publisher.Size()))
		n26, err := m.Publisher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Content != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Content.Size()))
		n27, err := m.Content.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Keywords != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Keywords)))
		i += copy(dAtA[i:], *m.Keywords)
	}
	if m.Storeurl != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Storeurl)))
		i += copy(dAtA[i:], *m.Storeurl)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n28, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Content) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Episode != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Episode))
	}
	if m.Title != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Title)))
		i += copy(dAtA[i:], *m.Title)
	}
	if m.Series != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Series)))
		i += copy(dAtA[i:], *m.Series)
	}
	if m.Season != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Season)))
		i += copy(dAtA[i:], *m.Season)
	}
	if m.Url != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Url)))
		i += copy(dAtA[i:], *m.Url)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Videoquality != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Videoquality))
	}
	if m.Keywords != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Keywords)))
		i += copy(dAtA[i:], *m.Keywords)
	}
	if m.Contentrating != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Contentrating)))
		i += copy(dAtA[i:], *m.Contentrating)
	}
	if m.Userrating != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Userrating)))
		i += copy(dAtA[i:], *m.Userrating)
	}
	if m.Context != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Context))
	}
	if m.Livestream != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Livestream))
	}
	if m.Sourcerelationship != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Sourcerelationship))
	}
	if m.Producer != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Producer.Size()))
		n29, err := m.Producer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Len != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Len))
	}
	if m.Qagmediarating != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Qagmediarating))
	}
	if m.Embeddable != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Embeddable))
	}
	if m.Language != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n30, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dnt != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Dnt))
	}
	if m.Ua != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ua)))
		i += copy(dAtA[i:], *m.Ua)
	}
	if m.Ip != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ip)))
		i += copy(dAtA[i:], *m.Ip)
	}
	if m.Geo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Geo.Size()))
		n31, err := m.Geo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Didsha1 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Didsha1)))
		i += copy(dAtA[i:], *m.Didsha1)
	}
	if m.Didmd5 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Didmd5)))
		i += copy(dAtA[i:], *m.Didmd5)
	}
	if m.Dpidsha1 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Dpidsha1)))
		i += copy(dAtA[i:], *m.Dpidsha1)
	}
	if m.Dpidmd5 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Dpidmd5)))
		i += copy(dAtA[i:], *m.Dpidmd5)
	}
	if m.Ipv6 != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ipv6)))
		i += copy(dAtA[i:], *m.Ipv6)
	}
	if m.Carrier != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Carrier)))
		i += copy(dAtA[i:], *m.Carrier)
	}
	if m.Language != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Make != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Make)))
		i += copy(dAtA[i:], *m.Make)
	}
	if m.Model != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Model)))
		i += copy(dAtA[i:], *m.Model)
	}
	if m.Os != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Os)))
		i += copy(dAtA[i:], *m.Os)
	}
	if m.Osv != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Osv)))
		i += copy(dAtA[i:], *m.Osv)
	}
	if m.Js != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Js))
	}
	if m.Connectiontype != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Connectiontype))
	}
	if m.Devicetype != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Devicetype))
	}
	if m.Flashver != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Flashver)))
		i += copy(dAtA[i:], *m.Flashver)
	}
	if m.Lmt != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if *m.Lmt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Hwv != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Hwv)))
		i += copy(dAtA[i:], *m.Hwv)
	}
	if m.W != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	if m.Ppi != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Ppi))
	}
	if m.Pxratio != nil {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Pxratio))))
		i += 8
	}
	if m.Ifa != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ifa)))
		i += copy(dAtA[i:], *m.Ifa)
	}
	if m.Macsha1 != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Macsha1)))
		i += copy(dAtA[i:], *m.Macsha1)
	}
	if m.Macmd5 != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Macmd5)))
		i += copy(dAtA[i:], *m.Macmd5)
	}
	if m.Mccmnc != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Mccmnc)))
		i += copy(dAtA[i:], *m.Mccmnc)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n32, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Buyeruid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Buyeruid)))
		i += copy(dAtA[i:], *m.Buyeruid)
	}
	if m.Yob != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Yob))
	}
	if m.Gender != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Gender)))
		i += copy(dAtA[i:], *m.Gender)
	}
	if m.Keywords != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Keywords)))
		i += copy(dAtA[i:], *m.Keywords)
	}
	if m.Customdata != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Customdata)))
		i += copy(dAtA[i:], *m.Customdata)
	}
	if m.Geo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Geo.Size()))
		n33, err := m.Geo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x42
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n34, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Publisher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Publisher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Domain != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n35, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Producer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Producer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Domain != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Domain)))
		i += copy(dAtA[i:], *m.Domain)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n36, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Geo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Geo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lat != nil {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Lat))))
		i += 8
	}
	if m.Lon != nil {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Lon))))
		i += 8
	}
	if m.Country != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Country)))
		i += copy(dAtA[i:], *m.Country)
	}
	if m.Region != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Region)))
		i += copy(dAtA[i:], *m.Region)
	}
	if m.Regionfips104 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Regionfips104)))
		i += copy(dAtA[i:], *m.Regionfips104)
	}
	if m.Metro != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Metro)))
		i += copy(dAtA[i:], *m.Metro)
	}
	if m.City != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.City)))
		i += copy(dAtA[i:], *m.City)
	}
	if m.Zip != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Zip)))
		i += copy(dAtA[i:], *m.Zip)
	}
	if m.Type != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Type))
	}
	if m.Utcoffset != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Utcoffset))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n37, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.Segment) > 0 {
		for _, msg := range m.Segment {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n38, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Data_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Data_Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n39, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest_Regulations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidRequest_Regulations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coppa != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Coppa))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n40, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if len(m.Seatbid) > 0 {
		for _, msg := range m.Seatbid {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Bidid != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Bidid)))
		i += copy(dAtA[i:], *m.Bidid)
	}
	if m.Cur != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Cur)))
		i += copy(dAtA[i:], *m.Cur)
	}
	if m.Customdata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Customdata)))
		i += copy(dAtA[i:], *m.Customdata)
	}
	if m.Nbr != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Nbr))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n41, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidResponse_SeatBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidResponse_SeatBid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bid) > 0 {
		for _, msg := range m.Bid {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seat != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Seat)))
		i += copy(dAtA[i:], *m.Seat)
	}
	if m.Group != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Group))
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n42, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidResponse_SeatBid_Bid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidResponse_SeatBid_Bid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Id)))
		i += copy(dAtA[i:], *m.Id)
	}
	if m.Impid == nil {
		return 0, proto.NewRequiredNotSetError("impid")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Impid)))
		i += copy(dAtA[i:], *m.Impid)
	}
	if m.Price == nil {
		return 0, proto.NewRequiredNotSetError("price")
	} else {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Price))))
		i += 8
	}
	if m.Adid != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Adid)))
		i += copy(dAtA[i:], *m.Adid)
	}
	if m.Nurl != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Nurl)))
		i += copy(dAtA[i:], *m.Nurl)
	}
	if m.Adm != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Adm)))
		i += copy(dAtA[i:], *m.Adm)
	}
	if len(m.Adomain) > 0 {
		for _, s := range m.Adomain {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Iurl != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Iurl)))
		i += copy(dAtA[i:], *m.Iurl)
	}
	if m.Cid != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Cid)))
		i += copy(dAtA[i:], *m.Cid)
	}
	if m.Crid != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Crid)))
		i += copy(dAtA[i:], *m.Crid)
	}
	if len(m.Attr) > 0 {
		for _, num := range m.Attr {
			dAtA[i] = 0x58
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(num))
		}
	}
	if m.Dealid != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Dealid)))
		i += copy(dAtA[i:], *m.Dealid)
	}
	if m.W != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	if m.Bundle != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Bundle)))
		i += copy(dAtA[i:], *m.Bundle)
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AdmNative != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.AdmNative.Size()))
		n43, err := m.AdmNative.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Ext != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Ext.Size()))
		n44, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ver)))
		i += copy(dAtA[i:], *m.Ver)
	}
	if m.Layout != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Layout))
	}
	if m.Adunit != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Adunit))
	}
	if m.Plcmtcnt != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Plcmtcnt))
	}
	if m.Seq != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Seq))
	}
	if len(m.Assets) > 0 {
		for _, msg := range m.Assets {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Context != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Context))
	}
	if m.Contextsubtype != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Contextsubtype))
	}
	if m.Plcmttype != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Plcmttype))
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeRequest_Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeRequest_Asset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Id))
	}
	if m.Required != nil {
		dAtA[i] = 0x10
		i++
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Title != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Title.Size()))
		n45, err := m.Title.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Img != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Img.Size()))
		n46, err := m.Img.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Video != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Video.Size()))
		n47, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Data != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Data.Size()))
		n48, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeRequest_Asset_Title) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeRequest_Asset_Title) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Len == nil {
		return 0, proto.NewRequiredNotSetError("len")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Len))
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeRequest_Asset_Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeRequest_Asset_Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Type))
	}
	if m.W != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	if m.Wmin != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Wmin))
	}
	if m.Hmin != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Hmin))
	}
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeRequest_Asset_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeRequest_Asset_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Type))
	}
	if m.Len != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Len))
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Ver)))
		i += copy(dAtA[i:], *m.Ver)
	}
	if len(m.Assets) > 0 {
		for _, msg := range m.Assets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpenrtb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Link == nil {
		return 0, proto.NewRequiredNotSetError("link")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Link.Size()))
		n49, err := m.Link.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.Imptrackers) > 0 {
		for _, s := range m.Imptrackers {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Jstracker != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Jstracker)))
		i += copy(dAtA[i:], *m.Jstracker)
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Link) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Url != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Url)))
		i += copy(dAtA[i:], *m.Url)
	}
	if len(m.Clicktrackers) > 0 {
		for _, s := range m.Clicktrackers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Fallback != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Fallback)))
		i += copy(dAtA[i:], *m.Fallback)
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Asset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.Id))
	}
	if m.Required != nil {
		dAtA[i] = 0x10
		i++
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Title != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Title.Size()))
		n50, err := m.Title.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Img != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Img.Size()))
		n51, err := m.Img.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Video != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Video.Size()))
		n52, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Data != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Data.Size()))
		n53, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Link != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(m.Link.Size()))
		n54, err := m.Link.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Asset_Title) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Asset_Title) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Text == nil {
		return 0, proto.NewRequiredNotSetError("text")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Text)))
		i += copy(dAtA[i:], *m.Text)
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Asset_Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Asset_Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Url != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Url)))
		i += copy(dAtA[i:], *m.Url)
	}
	if m.W != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.W))
	}
	if m.H != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(*m.H))
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Asset_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Asset_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Label != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.Value == nil {
		return 0, proto.NewRequiredNotSetError("value")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpenrtb(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NativeResponse_Asset_Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeResponse_Asset_Video) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vasttag) > 0 {
		for _, s := range m.Vasttag {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	n, err := proto.EncodeInternalExtension(m, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintOpenrtb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BidRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Imp) > 0 {
		for _, e := range m.Imp {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.At != nil {
		n += 1 + sovOpenrtb(uint64(*m.At))
	}
	if m.Tmax != nil {
		n += 1 + sovOpenrtb(uint64(*m.Tmax))
	}
	if len(m.Wseat) > 0 {
		for _, s := range m.Wseat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Allimps != nil {
		n += 1 + sovOpenrtb(uint64(*m.Allimps))
	}
	if len(m.Cur) > 0 {
		for _, s := range m.Cur {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Bcat) > 0 {
		for _, s := range m.Bcat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Badv) > 0 {
		for _, s := range m.Badv {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Regs != nil {
		l = m.Regs.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Test != nil {
		n += 2
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Source) Size() (n int) {
	var l int
	_ = l
	if m.Fd != nil {
		n += 2
	}
	if m.Tid != nil {
		l = len(*m.Tid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Pchain != nil {
		l = len(*m.Pchain)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Banner != nil {
		l = m.Banner.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Displaymanager != nil {
		l = len(*m.Displaymanager)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Displaymanagerver != nil {
		l = len(*m.Displaymanagerver)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Instl != nil {
		n += 1 + sovOpenrtb(uint64(*m.Instl))
	}
	if m.Tagid != nil {
		l = len(*m.Tagid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Bidfloor != nil {
		n += 9
	}
	if m.Bidfloorcur != nil {
		l = len(*m.Bidfloorcur)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Iframebuster) > 0 {
		for _, s := range m.Iframebuster {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Pmp != nil {
		l = m.Pmp.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Secure != nil {
		n += 1 + sovOpenrtb(uint64(*m.Secure))
	}
	if m.Native != nil {
		l = m.Native.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Exp != nil {
		n += 1 + sovOpenrtb(uint64(*m.Exp))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression_Banner) Size() (n int) {
	var l int
	_ = l
	if m.W != nil {
		n += 1 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sovOpenrtb(uint64(*m.H))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Pos != nil {
		n += 1 + sovOpenrtb(uint64(*m.Pos))
	}
	if len(m.Btype) > 0 {
		for _, e := range m.Btype {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if len(m.Battr) > 0 {
		for _, e := range m.Battr {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Topframe != nil {
		n += 1 + sovOpenrtb(uint64(*m.Topframe))
	}
	if len(m.Expdir) > 0 {
		for _, e := range m.Expdir {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if len(m.Api) > 0 {
		for _, e := range m.Api {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if m.Wmax != nil {
		n += 1 + sovOpenrtb(uint64(*m.Wmax))
	}
	if m.Hmax != nil {
		n += 1 + sovOpenrtb(uint64(*m.Hmax))
	}
	if m.Wmin != nil {
		n += 1 + sovOpenrtb(uint64(*m.Wmin))
	}
	if m.Hmin != nil {
		n += 1 + sovOpenrtb(uint64(*m.Hmin))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression_Video) Size() (n int) {
	var l int
	_ = l
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Linearity != nil {
		n += 1 + sovOpenrtb(uint64(*m.Linearity))
	}
	if m.Minduration != nil {
		n += 1 + sovOpenrtb(uint64(*m.Minduration))
	}
	if m.Maxduration != nil {
		n += 1 + sovOpenrtb(uint64(*m.Maxduration))
	}
	if len(m.Protocols) > 0 {
		for _, e := range m.Protocols {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if m.W != nil {
		n += 1 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sovOpenrtb(uint64(*m.H))
	}
	if m.Startdelay != nil {
		n += 1 + sovOpenrtb(uint64(*m.Startdelay))
	}
	if m.Sequence != nil {
		n += 1 + sovOpenrtb(uint64(*m.Sequence))
	}
	if len(m.Battr) > 0 {
		for _, e := range m.Battr {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if m.Maxextended != nil {
		n += 1 + sovOpenrtb(uint64(*m.Maxextended))
	}
	if m.Minbitrate != nil {
		n += 1 + sovOpenrtb(uint64(*m.Minbitrate))
	}
	if m.Maxbitrate != nil {
		n += 1 + sovOpenrtb(uint64(*m.Maxbitrate))
	}
	if m.Boxingallowed != nil {
		n += 1 + sovOpenrtb(uint64(*m.Boxingallowed))
	}
	if len(m.Playbackmethod) > 0 {
		for _, e := range m.Playbackmethod {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if len(m.Delivery) > 0 {
		for _, e := range m.Delivery {
			n += 2 + sovOpenrtb(uint64(e))
		}
	}
	if m.Pos != nil {
		n += 2 + sovOpenrtb(uint64(*m.Pos))
	}
	if len(m.Companionad) > 0 {
		for _, e := range m.Companionad {
			l = e.Size()
			n += 2 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Api) > 0 {
		for _, e := range m.Api {
			n += 2 + sovOpenrtb(uint64(e))
		}
	}
	if len(m.Companiontype) > 0 {
		for _, e := range m.Companiontype {
			n += 2 + sovOpenrtb(uint64(e))
		}
	}
	if m.Placement != nil {
		n += 2 + sovOpenrtb(uint64(*m.Placement))
	}
	if m.Playbackend != nil {
		n += 2 + sovOpenrtb(uint64(*m.Playbackend))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression_Native) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ver != nil {
		l = len(*m.Ver)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Api) > 0 {
		l = 0
		for _, e := range m.Api {
			l += sovOpenrtb(uint64(e))
		}
		n += 1 + sovOpenrtb(uint64(l)) + l
	}
	if len(m.Battr) > 0 {
		l = 0
		for _, e := range m.Battr {
			l += sovOpenrtb(uint64(e))
		}
		n += 1 + sovOpenrtb(uint64(l)) + l
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression_PMP) Size() (n int) {
	var l int
	_ = l
	if m.PrivateAuction != nil {
		n += 1 + sovOpenrtb(uint64(*m.PrivateAuction))
	}
	if len(m.Deals) > 0 {
		for _, e := range m.Deals {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Impression_PMP_DirectDeal) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Bidfloor != nil {
		n += 9
	}
	if m.Bidfloorcur != nil {
		l = len(*m.Bidfloorcur)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Wseat) > 0 {
		for _, s := range m.Wseat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Wadomain) > 0 {
		for _, s := range m.Wadomain {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.At != nil {
		n += 1 + sovOpenrtb(uint64(*m.At))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Site) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Sectioncat) > 0 {
		for _, s := range m.Sectioncat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Pagecat) > 0 {
		for _, s := range m.Pagecat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Page != nil {
		l = len(*m.Page)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Privacypolicy != nil {
		n += 1 + sovOpenrtb(uint64(*m.Privacypolicy))
	}
	if m.Ref != nil {
		l = len(*m.Ref)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Search != nil {
		l = len(*m.Search)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Publisher != nil {
		l = m.Publisher.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Keywords != nil {
		l = len(*m.Keywords)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Mobile != nil {
		n += 2
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_App) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Sectioncat) > 0 {
		for _, s := range m.Sectioncat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if len(m.Pagecat) > 0 {
		for _, s := range m.Pagecat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Ver != nil {
		l = len(*m.Ver)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Bundle != nil {
		l = len(*m.Bundle)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Privacypolicy != nil {
		n += 1 + sovOpenrtb(uint64(*m.Privacypolicy))
	}
	if m.Paid != nil {
		n += 1 + sovOpenrtb(uint64(*m.Paid))
	}
	if m.Publisher != nil {
		l = m.Publisher.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Keywords != nil {
		l = len(*m.Keywords)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Storeurl != nil {
		l = len(*m.Storeurl)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Content) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Episode != nil {
		n += 1 + sovOpenrtb(uint64(*m.Episode))
	}
	if m.Title != nil {
		l = len(*m.Title)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Series != nil {
		l = len(*m.Series)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Season != nil {
		l = len(*m.Season)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Videoquality != nil {
		n += 1 + sovOpenrtb(uint64(*m.Videoquality))
	}
	if m.Keywords != nil {
		l = len(*m.Keywords)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Contentrating != nil {
		l = len(*m.Contentrating)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Userrating != nil {
		l = len(*m.Userrating)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Context != nil {
		n += 1 + sovOpenrtb(uint64(*m.Context))
	}
	if m.Livestream != nil {
		n += 1 + sovOpenrtb(uint64(*m.Livestream))
	}
	if m.Sourcerelationship != nil {
		n += 1 + sovOpenrtb(uint64(*m.Sourcerelationship))
	}
	if m.Producer != nil {
		l = m.Producer.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Len != nil {
		n += 2 + sovOpenrtb(uint64(*m.Len))
	}
	if m.Qagmediarating != nil {
		n += 2 + sovOpenrtb(uint64(*m.Qagmediarating))
	}
	if m.Embeddable != nil {
		n += 2 + sovOpenrtb(uint64(*m.Embeddable))
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Device) Size() (n int) {
	var l int
	_ = l
	if m.Dnt != nil {
		n += 1 + sovOpenrtb(uint64(*m.Dnt))
	}
	if m.Ua != nil {
		l = len(*m.Ua)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Geo != nil {
		l = m.Geo.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Didsha1 != nil {
		l = len(*m.Didsha1)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Didmd5 != nil {
		l = len(*m.Didmd5)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Dpidsha1 != nil {
		l = len(*m.Dpidsha1)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Dpidmd5 != nil {
		l = len(*m.Dpidmd5)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ipv6 != nil {
		l = len(*m.Ipv6)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Carrier != nil {
		l = len(*m.Carrier)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Make != nil {
		l = len(*m.Make)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Model != nil {
		l = len(*m.Model)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Os != nil {
		l = len(*m.Os)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Osv != nil {
		l = len(*m.Osv)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Js != nil {
		n += 2 + sovOpenrtb(uint64(*m.Js))
	}
	if m.Connectiontype != nil {
		n += 2 + sovOpenrtb(uint64(*m.Connectiontype))
	}
	if m.Devicetype != nil {
		n += 2 + sovOpenrtb(uint64(*m.Devicetype))
	}
	if m.Flashver != nil {
		l = len(*m.Flashver)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Lmt != nil {
		n += 3
	}
	if m.Hwv != nil {
		l = len(*m.Hwv)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.W != nil {
		n += 2 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 2 + sovOpenrtb(uint64(*m.H))
	}
	if m.Ppi != nil {
		n += 2 + sovOpenrtb(uint64(*m.Ppi))
	}
	if m.Pxratio != nil {
		n += 10
	}
	if m.Ifa != nil {
		l = len(*m.Ifa)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Macsha1 != nil {
		l = len(*m.Macsha1)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Macmd5 != nil {
		l = len(*m.Macmd5)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Mccmnc != nil {
		l = len(*m.Mccmnc)
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_User) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Buyeruid != nil {
		l = len(*m.Buyeruid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Yob != nil {
		n += 1 + sovOpenrtb(uint64(*m.Yob))
	}
	if m.Gender != nil {
		l = len(*m.Gender)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Keywords != nil {
		l = len(*m.Keywords)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Customdata != nil {
		l = len(*m.Customdata)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Geo != nil {
		l = m.Geo.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Publisher) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Producer) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Geo) Size() (n int) {
	var l int
	_ = l
	if m.Lat != nil {
		n += 9
	}
	if m.Lon != nil {
		n += 9
	}
	if m.Country != nil {
		l = len(*m.Country)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Region != nil {
		l = len(*m.Region)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Regionfips104 != nil {
		l = len(*m.Regionfips104)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Metro != nil {
		l = len(*m.Metro)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Zip != nil {
		l = len(*m.Zip)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovOpenrtb(uint64(*m.Type))
	}
	if m.Utcoffset != nil {
		n += 1 + sovOpenrtb(uint64(*m.Utcoffset))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Data) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Segment) > 0 {
		for _, e := range m.Segment {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Data_Segment) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest_Regulations) Size() (n int) {
	var l int
	_ = l
	if m.Coppa != nil {
		n += 1 + sovOpenrtb(uint64(*m.Coppa))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidResponse) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Seatbid) > 0 {
		for _, e := range m.Seatbid {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Bidid != nil {
		l = len(*m.Bidid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Cur != nil {
		l = len(*m.Cur)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Customdata != nil {
		l = len(*m.Customdata)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Nbr != nil {
		n += 1 + sovOpenrtb(uint64(*m.Nbr))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidResponse_SeatBid) Size() (n int) {
	var l int
	_ = l
	if len(m.Bid) > 0 {
		for _, e := range m.Bid {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Seat != nil {
		l = len(*m.Seat)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Group != nil {
		n += 1 + sovOpenrtb(uint64(*m.Group))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidResponse_SeatBid_Bid) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Impid != nil {
		l = len(*m.Impid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Price != nil {
		n += 9
	}
	if m.Adid != nil {
		l = len(*m.Adid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Nurl != nil {
		l = len(*m.Nurl)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Adm != nil {
		l = len(*m.Adm)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Adomain) > 0 {
		for _, s := range m.Adomain {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Iurl != nil {
		l = len(*m.Iurl)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Cid != nil {
		l = len(*m.Cid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Crid != nil {
		l = len(*m.Crid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Attr) > 0 {
		for _, e := range m.Attr {
			n += 1 + sovOpenrtb(uint64(e))
		}
	}
	if m.Dealid != nil {
		l = len(*m.Dealid)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.W != nil {
		n += 1 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sovOpenrtb(uint64(*m.H))
	}
	if m.Bundle != nil {
		l = len(*m.Bundle)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Cat) > 0 {
		for _, s := range m.Cat {
			l = len(s)
			n += 2 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.AdmNative != nil {
		l = m.AdmNative.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 2 + l + sovOpenrtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ver != nil {
		l = len(*m.Ver)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Layout != nil {
		n += 1 + sovOpenrtb(uint64(*m.Layout))
	}
	if m.Adunit != nil {
		n += 1 + sovOpenrtb(uint64(*m.Adunit))
	}
	if m.Plcmtcnt != nil {
		n += 1 + sovOpenrtb(uint64(*m.Plcmtcnt))
	}
	if m.Seq != nil {
		n += 1 + sovOpenrtb(uint64(*m.Seq))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Context != nil {
		n += 1 + sovOpenrtb(uint64(*m.Context))
	}
	if m.Contextsubtype != nil {
		n += 1 + sovOpenrtb(uint64(*m.Contextsubtype))
	}
	if m.Plcmttype != nil {
		n += 1 + sovOpenrtb(uint64(*m.Plcmttype))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeRequest_Asset) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOpenrtb(uint64(*m.Id))
	}
	if m.Required != nil {
		n += 2
	}
	if m.Title != nil {
		l = m.Title.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Img != nil {
		l = m.Img.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeRequest_Asset_Title) Size() (n int) {
	var l int
	_ = l
	if m.Len != nil {
		n += 1 + sovOpenrtb(uint64(*m.Len))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeRequest_Asset_Image) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovOpenrtb(uint64(*m.Type))
	}
	if m.W != nil {
		n += 1 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sovOpenrtb(uint64(*m.H))
	}
	if m.Wmin != nil {
		n += 1 + sovOpenrtb(uint64(*m.Wmin))
	}
	if m.Hmin != nil {
		n += 1 + sovOpenrtb(uint64(*m.Hmin))
	}
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeRequest_Asset_Data) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovOpenrtb(uint64(*m.Type))
	}
	if m.Len != nil {
		n += 1 + sovOpenrtb(uint64(*m.Len))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Ver != nil {
		l = len(*m.Ver)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Imptrackers) > 0 {
		for _, s := range m.Imptrackers {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Jstracker != nil {
		l = len(*m.Jstracker)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Link) Size() (n int) {
	var l int
	_ = l
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if len(m.Clicktrackers) > 0 {
		for _, s := range m.Clicktrackers {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	if m.Fallback != nil {
		l = len(*m.Fallback)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Asset) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOpenrtb(uint64(*m.Id))
	}
	if m.Required != nil {
		n += 2
	}
	if m.Title != nil {
		l = m.Title.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Img != nil {
		l = m.Img.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Asset_Title) Size() (n int) {
	var l int
	_ = l
	if m.Text != nil {
		l = len(*m.Text)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Asset_Image) Size() (n int) {
	var l int
	_ = l
	if m.Url != nil {
		l = len(*m.Url)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.W != nil {
		n += 1 + sovOpenrtb(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sovOpenrtb(uint64(*m.H))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Asset_Data) Size() (n int) {
	var l int
	_ = l
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovOpenrtb(uint64(l))
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NativeResponse_Asset_Video) Size() (n int) {
	var l int
	_ = l
	if len(m.Vasttag) > 0 {
		for _, s := range m.Vasttag {
			l = len(s)
			n += 1 + l + sovOpenrtb(uint64(l))
		}
	}
	n += proto.SizeOfInternalExtension(m)
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOpenrtb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpenrtb(x uint64) (n int) {
	return sovOpenrtb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BidRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imp = append(m.Imp, &BidRequest_Impression{})
			if err := m.Imp[len(m.Imp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &BidRequest_Site{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &BidRequest_App{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &BidRequest_Device{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &BidRequest_User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.At = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tmax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tmax = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wseat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wseat = append(m.Wseat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allimps", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allimps = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cur = append(m.Cur, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bcat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bcat = append(m.Bcat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badv = append(m.Badv, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regs == nil {
				m.Regs = &BidRequest_Regulations{}
			}
			if err := m.Regs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Test = &b
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &BidRequest_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &BidRequestExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Fd = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tid = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pchain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pchain = &s
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Impression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Impression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Banner == nil {
				m.Banner = &BidRequest_Impression_Banner{}
			}
			if err := m.Banner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &BidRequest_Impression_Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Displaymanager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Displaymanager = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Displaymanagerver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Displaymanagerver = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instl", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Instl = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tagid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tagid = &s
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidfloor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Bidfloor = &v2
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidfloorcur", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bidfloorcur = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iframebuster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iframebuster = append(m.Iframebuster, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pmp == nil {
				m.Pmp = &BidRequest_Impression_PMP{}
			}
			if err := m.Pmp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Native", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Native == nil {
				m.Native = &BidRequest_Impression_Native{}
			}
			if err := m.Native.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exp = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &ImpressionExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression_Banner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Banner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Banner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var v Enums_BidRequest_Impression_AdPosition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_AdPosition(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pos = &v
		case 5:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Banner_AdType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Banner_AdType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Btype = append(m.Btype, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Banner_AdType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Banner_AdType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Btype = append(m.Btype, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Btype", wireType)
			}
		case 6:
			if wireType == 0 {
				var v CreativeAttribute
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CreativeAttribute(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Battr = append(m.Battr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CreativeAttribute
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CreativeAttribute(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Battr = append(m.Battr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Battr", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimes = append(m.Mimes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topframe", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Topframe = &v
		case 9:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Banner_ExpandableDirection
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Banner_ExpandableDirection(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Expdir = append(m.Expdir, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Banner_ExpandableDirection
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Banner_ExpandableDirection(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Expdir = append(m.Expdir, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Expdir", wireType)
			}
		case 10:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_ApiFramework
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Api = append(m.Api, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_ApiFramework
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Api = append(m.Api, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Api", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wmax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wmax = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hmax = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wmin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wmin = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hmin = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &BannerExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression_Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimes = append(m.Mimes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linearity", wireType)
			}
			var v Enums_BidRequest_Impression_Video_Linearity
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_Video_Linearity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Linearity = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minduration", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Minduration = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxduration", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maxduration = &v
		case 5:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Video_Protocol
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Video_Protocol(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Protocols = append(m.Protocols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Video_Protocol
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Video_Protocol(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Protocols = append(m.Protocols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocols", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startdelay", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Startdelay = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sequence = &v
		case 10:
			if wireType == 0 {
				var v CreativeAttribute
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CreativeAttribute(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Battr = append(m.Battr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CreativeAttribute
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CreativeAttribute(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Battr = append(m.Battr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Battr", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxextended", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maxextended = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minbitrate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Minbitrate = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxbitrate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maxbitrate = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boxingallowed", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Boxingallowed = &v
		case 15:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Video_PlaybackMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Video_PlaybackMethod(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Playbackmethod = append(m.Playbackmethod, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Video_PlaybackMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Video_PlaybackMethod(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Playbackmethod = append(m.Playbackmethod, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Playbackmethod", wireType)
			}
		case 16:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Video_ContentDelivery
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Video_ContentDelivery(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Delivery = append(m.Delivery, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Video_ContentDelivery
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Video_ContentDelivery(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Delivery = append(m.Delivery, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivery", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var v Enums_BidRequest_Impression_AdPosition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_AdPosition(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pos = &v
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Companionad", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Companionad = append(m.Companionad, &BidRequest_Impression_Banner{})
			if err := m.Companionad[len(m.Companionad)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_ApiFramework
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Api = append(m.Api, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_ApiFramework
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Api = append(m.Api, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Api", wireType)
			}
		case 20:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_Video_CompanionType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_Video_CompanionType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Companiontype = append(m.Companiontype, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_Video_CompanionType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_Video_CompanionType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Companiontype = append(m.Companiontype, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Companiontype", wireType)
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Placement", wireType)
			}
			var v Enums_BidRequest_Impression_Video_VideoPlacementType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_Video_VideoPlacementType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Placement = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Playbackend", wireType)
			}
			var v Enums_BidRequest_Impression_Video_PlaybackCessationMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_Video_PlaybackCessationMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Playbackend = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &VideoExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression_Native) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Native: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Native: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &NativeRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ver = &s
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Enums_BidRequest_Impression_ApiFramework
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Api = append(m.Api, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Enums_BidRequest_Impression_ApiFramework
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Enums_BidRequest_Impression_ApiFramework(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Api = append(m.Api, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Api", wireType)
			}
		case 4:
			if wireType == 0 {
				var v CreativeAttribute
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CreativeAttribute(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Battr = append(m.Battr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CreativeAttribute
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CreativeAttribute(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Battr = append(m.Battr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Battr", wireType)
			}
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &NativeExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("request")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression_PMP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PMP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PMP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateAuction", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrivateAuction = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deals = append(m.Deals, &BidRequest_Impression_PMP_DirectDeal{})
			if err := m.Deals[len(m.Deals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &PMPExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Impression_PMP_DirectDeal) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectDeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectDeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidfloor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Bidfloor = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidfloorcur", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bidfloorcur = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wseat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wseat = append(m.Wseat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wadomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wadomain = append(m.Wadomain, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.At = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &DirectDealExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Site) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Site: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Site: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sectioncat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sectioncat = append(m.Sectioncat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagecat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pagecat = append(m.Pagecat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Page = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privacypolicy", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privacypolicy = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ref = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Search = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publisher == nil {
				m.Publisher = &BidRequest_Publisher{}
			}
			if err := m.Publisher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &BidRequest_Content{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Keywords = &s
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mobile = &b
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &SiteExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sectioncat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sectioncat = append(m.Sectioncat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagecat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pagecat = append(m.Pagecat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ver = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bundle = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privacypolicy", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privacypolicy = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paid = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publisher == nil {
				m.Publisher = &BidRequest_Publisher{}
			}
			if err := m.Publisher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &BidRequest_Content{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Keywords = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storeurl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Storeurl = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &AppExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Episode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Episode = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Title = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Series = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Season = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videoquality", wireType)
			}
			var v Enums_BidRequest_Content_VideoQuality
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Content_VideoQuality(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Videoquality = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Keywords = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contentrating", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Contentrating = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userrating", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Userrating = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var v Enums_BidRequest_Content_Context
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Content_Context(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Context = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Livestream", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Livestream = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sourcerelationship", wireType)
			}
			var v Enums_BidRequest_Content_SourceRelationship
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Content_SourceRelationship(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sourcerelationship = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Producer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Producer == nil {
				m.Producer = &BidRequest_Producer{}
			}
			if err := m.Producer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Len = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qagmediarating", wireType)
			}
			var v Enums_BidRequest_Content_QAGMediaRating
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Content_QAGMediaRating(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qagmediarating = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embeddable", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Embeddable = &v
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &ContentExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnt", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dnt = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ua", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ua = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Geo == nil {
				m.Geo = &BidRequest_Geo{}
			}
			if err := m.Geo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Didsha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Didsha1 = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Didmd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Didmd5 = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dpidsha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Dpidsha1 = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dpidmd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Dpidmd5 = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ipv6 = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Carrier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Carrier = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Make", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Make = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Model = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Os = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Osv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Osv = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Js", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Js = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectiontype", wireType)
			}
			var v Enums_BidRequest_Device_ConnectionType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Device_ConnectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connectiontype = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devicetype", wireType)
			}
			var v Enums_BidRequest_Device_DeviceType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Device_DeviceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Devicetype = &v
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flashver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Flashver = &s
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lmt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lmt = &b
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hwv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hwv = &s
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppi", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ppi = &v
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pxratio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Pxratio = &v2
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ifa = &s
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Macsha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Macsha1 = &s
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Macmd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Macmd5 = &s
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mccmnc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mccmnc = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &DeviceExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyeruid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Buyeruid = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yob", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Yob = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Gender = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Keywords = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customdata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Customdata = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Geo == nil {
				m.Geo = &BidRequest_Geo{}
			}
			if err := m.Geo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &BidRequest_Data{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &UserExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Publisher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Publisher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Publisher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &PublisherExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Producer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Producer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Producer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &ProducerExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Geo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Geo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Geo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Lat = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Lon = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Country = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Region = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regionfips104", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Regionfips104 = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metro", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Metro = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Zip = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Enums_BidRequest_Geo_LocationType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Geo_LocationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Utcoffset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Utcoffset = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &GeoExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segment = append(m.Segment, &BidRequest_Data_Segment{})
			if err := m.Segment[len(m.Segment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &DataExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Data_Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &SegmentExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidRequest_Regulations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Regulations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Regulations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coppa", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Coppa = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &RegulationsExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seatbid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seatbid = append(m.Seatbid, &BidResponse_SeatBid{})
			if err := m.Seatbid[len(m.Seatbid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bidid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bidid = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cur = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customdata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Customdata = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbr", wireType)
			}
			var v Enums_BidResponse_NoBidReason
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidResponse_NoBidReason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nbr = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &BidResponseExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidResponse_SeatBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bid = append(m.Bid, &BidResponse_SeatBid_Bid{})
			if err := m.Bid[len(m.Bid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Seat = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var v Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Group = &v
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &SeatBidExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidResponse_SeatBid_Bid) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Impid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Price = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Adid = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nurl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Nurl = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Adm = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adomain = append(m.Adomain, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iurl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Iurl = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cid = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Crid = &s
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v CreativeAttribute
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CreativeAttribute(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Attr = append(m.Attr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpenrtb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CreativeAttribute
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpenrtb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CreativeAttribute(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Attr = append(m.Attr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Dealid = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Bundle = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat = append(m.Cat, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmNative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdmNative == nil {
				m.AdmNative = &NativeResponse{}
			}
			if err := m.AdmNative.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &BidExtensions{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpenrtb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenrtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("impid")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("price")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NativeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NativeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ver = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var v Enums_BidRequest_Impression_NativeRequest_LayoutId
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_NativeRequest_LayoutId(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Layout = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adunit", wireType)
			}
			var v Enums_BidRequest_Impression_NativeRequest_AdUnitId
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_NativeRequest_AdUnitId(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Adunit = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plcmtcnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Plcmtcnt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Seq = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &NativeRequest_Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var v Enums_BidRequest_Impression_NativeRequest_Context
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_NativeRequest_Context(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Context = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contextsubtype", wireType)
			}
			var v Enums_BidRequest_Impression_NativeRequest_ContextSubtype
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_NativeRequest_ContextSubtype(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Contextsubtype = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plcmttype", wireType)
			}
			var v Enums_BidRequest_Impression_NativeRequest_PlacementType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Enums_BidRequest_Impression_NativeRequest_PlacementType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Plcmttype = &v
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeRequest_Asset) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Title == nil {
				m.Title = &NativeRequest_Asset_Title{}
			}
			if err := m.Title.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Img == nil {
				m.Img = &NativeRequest_Asset_Image{}
			}
			if err := m.Img.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &BidRequest_Impression_Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &NativeRequest_Asset_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeRequest_Asset_Title) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Title: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Title: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Len = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("len")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeRequest_Asset_Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v NativeRequest_Asset_Image_ImageAssetType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NativeRequest_Asset_Image_ImageAssetType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wmin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wmin = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hmin = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimes = append(m.Mimes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeRequest_Asset_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v NativeRequest_Asset_Data_DataAssetType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NativeRequest_Asset_Data_DataAssetType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Len = &v
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NativeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NativeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ver = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &NativeResponse_Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &NativeResponse_Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imptrackers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imptrackers = append(m.Imptrackers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jstracker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Jstracker = &s
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("link")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clicktrackers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clicktrackers = append(m.Clicktrackers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fallback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Fallback = &s
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Asset) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Title == nil {
				m.Title = &NativeResponse_Asset_Title{}
			}
			if err := m.Title.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Img == nil {
				m.Img = &NativeResponse_Asset_Image{}
			}
			if err := m.Img.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &NativeResponse_Asset_Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &NativeResponse_Asset_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &NativeResponse_Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Asset_Title) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Title: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Title: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Text = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Asset_Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.H = &v
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Asset_Data) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeResponse_Asset_Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vasttag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpenrtb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vasttag = append(m.Vasttag, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			if (fieldNum >= 100) && (fieldNum < 10000) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipOpenrtb(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthOpenrtb
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpenrtb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpenrtb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpenrtb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpenrtb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOpenrtb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpenrtb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpenrtb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpenrtb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("beeswax/openrtb/openrtb.proto", fileDescriptorOpenrtb) }

var fileDescriptorOpenrtb = []byte{
	// 3772 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0xcd, 0x6f, 0x1c, 0x47,
	0x76, 0xc7, 0x7c, 0xf4, 0x7c, 0xbc, 0x11, 0xe9, 0x71, 0x49, 0x2b, 0xb7, 0x69, 0x4b, 0xa6, 0x69,
	0xef, 0x86, 0x6b, 0x5b, 0x63, 0x69, 0x2c, 0x09, 0x32, 0x37, 0x4e, 0x76, 0x4c, 0x72, 0xb5, 0xc4,
	0x52, 0x43, 0xba, 0x86, 0x5a, 0x67, 0x13, 0x60, 0x8d, 0x9a, 0xee, 0xe2, 0xb0, 0xcc, 0xfe, 0x52,
	0x77, 0x0f, 0x3f, 0x72, 0x0e, 0x16, 0x41, 0x4e, 0xb9, 0x07, 0x41, 0x6e, 0x39, 0xe5, 0x98, 0x3f,
	0x20, 0xa7, 0x45, 0x8e, 0xb9, 0x24, 0x7b, 0x4c, 0xe0, 0x43, 0xb0, 0xe7, 0x20, 0x97, 0xe4, 0x14,
	0xbc, 0x57, 0xd5, 0xd3, 0xd3, 0xf3, 0x21, 0x52, 0xda, 0x45, 0x20, 0x40, 0xac, 0xf7, 0xfa, 0xd5,
	0xab, 0xd7, 0x55, 0xbf, 0x7a, 0x5f, 0x3d, 0x70, 0x67, 0x28, 0x65, 0x72, 0x2e, 0x2e, 0x3e, 0x0d,
	0x23, 0x19, 0xc4, 0xe9, 0x30, 0xfb, 0xdb, 0x89, 0xe2, 0x30, 0x0d, 0x59, 0xdd, 0x90, 0x6b, 0xef,
	0xcd, 0xca, 0xc9, 0x8b, 0x54, 0x06, 0x89, 0x0a, 0x03, 0x2d, 0xb9, 0xf6, 0xe1, 0x12, 0x45, 0xdf,
	0x38, 0xa1, 0xef, 0x67, 0x52, 0x1b, 0xbf, 0xf9, 0x02, 0xe0, 0x4b, 0xe5, 0x72, 0xf9, 0x62, 0x2c,
	0x93, 0x94, 0xad, 0x42, 0x59, 0xb9, 0x76, 0x69, 0xbd, 0xbc, 0xd9, 0xe4, 0x65, 0xe5, 0xb2, 0xfb,
	0x50, 0x51, 0x7e, 0x64, 0x97, 0xd7, 0x2b, 0x9b, 0xad, 0xee, 0xdd, 0x4e, 0x66, 0x4b, 0x3e, 0xa3,
	0xb3, 0xe7, 0x47, 0xb1, 0x4c, 0x70, 0x5d, 0x8e, 0xa2, 0xec, 0x13, 0xa8, 0x26, 0x2a, 0x95, 0x76,
	0x65, 0xbd, 0xb4, 0xd9, 0xea, 0xda, 0x8b, 0xa6, 0x0c, 0x54, 0x2a, 0x39, 0x49, 0xb1, 0x1f, 0x42,
	0x45, 0x44, 0x91, 0x5d, 0x25, 0xe1, 0xb7, 0x16, 0x09, 0xf7, 0xa2, 0x88, 0xa3, 0x0c, 0xeb, 0x42,
	0xcd, 0x95, 0x67, 0xca, 0x91, 0xb6, 0x45, 0xd2, 0x6b, 0x8b, 0xa4, 0x77, 0x48, 0x82, 0x1b, 0x49,
	0x34, 0x66, 0x9c, 0xc8, 0xd8, 0xae, 0x2d, 0x37, 0xe6, 0x79, 0x22, 0x63, 0x4e, 0x52, 0xec, 0x4d,
	0x28, 0x8b, 0xd4, 0xae, 0xaf, 0x97, 0x36, 0xad, 0xad, 0x52, 0x97, 0x97, 0x45, 0xca, 0x18, 0x54,
	0x53, 0x5f, 0x5c, 0xd8, 0x0d, 0x64, 0x72, 0x1a, 0xb3, 0x5b, 0x60, 0x9d, 0x27, 0x52, 0xa4, 0x76,
	0x73, 0xbd, 0xb2, 0xd9, 0xe4, 0x9a, 0x60, 0x1f, 0x43, 0x5d, 0x78, 0x9e, 0xf2, 0xa3, 0xc4, 0x86,
	0xf5, 0xd2, 0xe6, 0x6a, 0x77, 0x65, 0xb2, 0xda, 0x4f, 0x3c, 0x31, 0xda, 0x2a, 0xf7, 0x0f, 0x78,
	0x26, 0xc1, 0xda, 0x50, 0x71, 0xc6, 0xb1, 0xdd, 0x22, 0x05, 0x38, 0xc4, 0x85, 0x86, 0x8e, 0x48,
	0xed, 0x1b, 0xc4, 0xa2, 0x31, 0xf1, 0x84, 0x7b, 0x66, 0xaf, 0x18, 0x9e, 0x70, 0xcf, 0xd8, 0x67,
	0x50, 0x8d, 0xe5, 0x28, 0xb1, 0x57, 0xe9, 0x8d, 0xde, 0x5b, 0xf4, 0x46, 0x5c, 0x8e, 0xc6, 0x9e,
	0x48, 0x55, 0x18, 0x24, 0x9c, 0x84, 0xd9, 0xdb, 0x50, 0x4d, 0x65, 0x92, 0xda, 0x6f, 0xac, 0x97,
	0x36, 0x1b, 0x5b, 0xd6, 0xb1, 0xf0, 0x12, 0xc9, 0x89, 0x85, 0xbb, 0x9a, 0x84, 0xe3, 0xd8, 0x91,
	0xf6, 0xcd, 0xe5, 0xbb, 0x3a, 0x20, 0x09, 0x6e, 0x24, 0x11, 0x14, 0xf2, 0x22, 0xb5, 0x7f, 0x5b,
	0xa7, 0x19, 0x77, 0x16, 0xcc, 0xd8, 0xcd, 0xb0, 0x98, 0x70, 0x14, 0x5d, 0xdb, 0x83, 0x9a, 0xd6,
	0x81, 0x00, 0x3b, 0x46, 0x80, 0x95, 0x36, 0x1b, 0xbc, 0x7c, 0xec, 0xe2, 0x4e, 0xa4, 0xca, 0xb5,
	0xcb, 0xeb, 0x25, 0xdc, 0x89, 0x54, 0xb9, 0xec, 0x36, 0xd4, 0x22, 0xe7, 0x44, 0xa8, 0x80, 0x20,
	0xd4, 0xe4, 0x86, 0xfa, 0xc8, 0x6a, 0xb8, 0xed, 0xbf, 0xee, 0xaf, 0xfd, 0xc5, 0xdb, 0x00, 0x39,
	0xe6, 0xe6, 0x00, 0xfb, 0x05, 0xd4, 0x86, 0x22, 0x08, 0x64, 0x4c, 0x2a, 0x5b, 0xdd, 0xef, 0xbf,
	0x1c, 0xb3, 0x9d, 0x2f, 0x49, 0x98, 0x9b, 0x49, 0x6c, 0x0b, 0xac, 0x33, 0xe5, 0xca, 0xd0, 0xc0,
	0xf7, 0xc3, 0x2b, 0x66, 0xff, 0x1c, 0x65, 0xb9, 0x9e, 0xc2, 0x7e, 0x00, 0xab, 0xae, 0x4a, 0x22,
	0x4f, 0x5c, 0xfa, 0x22, 0x10, 0x23, 0x19, 0x13, 0xac, 0x9b, 0x7c, 0x86, 0xcb, 0x3e, 0x81, 0x37,
	0x8b, 0x9c, 0x33, 0x19, 0x13, 0xa6, 0x9b, 0x7c, 0xfe, 0x01, 0xfb, 0x03, 0xb0, 0x54, 0x90, 0xa4,
	0x1e, 0x61, 0x78, 0x21, 0xaa, 0xf4, 0x73, 0x84, 0x65, 0x2a, 0x46, 0xca, 0x25, 0x00, 0x37, 0xb9,
	0x26, 0xd8, 0x1d, 0x68, 0x0c, 0x95, 0x7b, 0xec, 0x85, 0x61, 0x4c, 0x20, 0x2e, 0x6d, 0x95, 0xee,
	0xf3, 0x09, 0x8b, 0x7d, 0x1f, 0x5a, 0xd9, 0x18, 0x01, 0xd9, 0xc4, 0xa9, 0x5b, 0x95, 0xe7, 0x83,
	0x1d, 0x3e, 0xcd, 0x67, 0x1b, 0x70, 0x43, 0x1d, 0xc7, 0xc2, 0x97, 0xc3, 0x71, 0x92, 0xca, 0xd8,
	0x06, 0x42, 0x64, 0x81, 0xc7, 0x1e, 0x42, 0x25, 0xf2, 0x23, 0xbb, 0x45, 0x1b, 0xb7, 0x71, 0xc5,
	0xc6, 0x1d, 0x3e, 0x3b, 0xe4, 0x28, 0x8e, 0xa7, 0x9d, 0x48, 0x67, 0x1c, 0x4b, 0xfb, 0x06, 0x5d,
	0x31, 0x43, 0xe1, 0x39, 0x06, 0x22, 0x55, 0x67, 0xd2, 0x5e, 0xb9, 0xd6, 0x39, 0xf6, 0x49, 0x98,
	0x9b, 0x49, 0x08, 0x2b, 0x79, 0x11, 0xd1, 0x2d, 0xb1, 0x10, 0x82, 0xd1, 0x52, 0xd0, 0xe6, 0x3a,
	0x66, 0x41, 0xfb, 0x9f, 0x55, 0xa8, 0x69, 0x78, 0xb0, 0x1b, 0x50, 0x3a, 0x27, 0xd0, 0x5a, 0xbc,
	0x74, 0x8e, 0xd4, 0x09, 0xc1, 0xcb, 0xe2, 0xa5, 0x13, 0x83, 0x40, 0x8d, 0x55, 0x44, 0xe0, 0x00,
	0x2a, 0x51, 0x98, 0xd0, 0xd9, 0xaf, 0x76, 0x3f, 0x9d, 0xac, 0xb3, 0x1b, 0x8c, 0xfd, 0x64, 0x89,
	0xf1, 0x3d, 0xf7, 0x30, 0x4c, 0x14, 0xde, 0xd8, 0xad, 0xf6, 0xe1, 0xc1, 0x60, 0xef, 0x68, 0xef,
	0xa0, 0xff, 0xcd, 0xf3, 0xfe, 0xcf, 0xfa, 0x07, 0x5f, 0xf7, 0x39, 0x6a, 0x63, 0x3f, 0x05, 0x6b,
	0x98, 0x5e, 0x46, 0xe8, 0xfb, 0x2a, 0x9b, 0xab, 0xdd, 0xee, 0xb5, 0xd4, 0x6a, 0xe3, 0x3b, 0x3d,
	0xf7, 0xe8, 0x32, 0x92, 0x5c, 0x2b, 0x60, 0xf7, 0xc1, 0x1a, 0x8a, 0x34, 0x45, 0x9f, 0x88, 0x9a,
	0xf2, 0xfb, 0xbe, 0x1d, 0x4b, 0xda, 0xbb, 0x5e, 0x9a, 0xc6, 0x6a, 0x38, 0x4e, 0x71, 0x06, 0x0a,
	0x22, 0xb0, 0x7c, 0xe5, 0xcb, 0xc4, 0xae, 0x6b, 0x7f, 0x47, 0x04, 0xbb, 0x07, 0x8d, 0x34, 0x8c,
	0x08, 0x00, 0x04, 0xac, 0x85, 0xd0, 0x9c, 0x88, 0xb0, 0xaf, 0xa1, 0x26, 0x2f, 0x22, 0x57, 0xc5,
	0xe4, 0x35, 0x57, 0xbb, 0x7f, 0xfc, 0x2a, 0x6f, 0xb0, 0x7b, 0x11, 0x89, 0xc0, 0x15, 0x43, 0x4f,
	0xee, 0xa8, 0x58, 0x3a, 0xb8, 0x51, 0xdc, 0xa8, 0x63, 0xdb, 0x18, 0x41, 0x14, 0x21, 0x72, 0xb5,
	0xfb, 0xe0, 0x7a, 0xdb, 0x1d, 0xa9, 0x9f, 0xa0, 0x51, 0xe7, 0x61, 0x7c, 0x8a, 0xb1, 0x45, 0xa1,
	0xa7, 0x3d, 0x47, 0x37, 0xdf, 0xd2, 0x6e, 0x1e, 0xc7, 0xc8, 0x3b, 0x41, 0x9e, 0xc6, 0x25, 0x8d,
	0xb5, 0x9c, 0x0a, 0x08, 0x93, 0x24, 0xa7, 0x02, 0x2d, 0xa7, 0x02, 0x83, 0x35, 0x1a, 0xb3, 0x4f,
	0x0a, 0x60, 0x7b, 0x3b, 0xc7, 0x2e, 0xbd, 0xcf, 0x2c, 0xd0, 0xfe, 0x01, 0xc0, 0x22, 0x4f, 0x92,
	0x6f, 0x75, 0x69, 0x7a, 0xab, 0xff, 0x14, 0x9a, 0x9e, 0x0a, 0xa4, 0x88, 0x55, 0x7a, 0x49, 0xb8,
	0x5b, 0xed, 0x3e, 0xbc, 0xd6, 0x8b, 0x92, 0xd2, 0xce, 0x7e, 0x36, 0x77, 0xab, 0xb6, 0xbf, 0xd7,
	0xdf, 0xed, 0x71, 0x9e, 0xab, 0x63, 0xeb, 0xd0, 0xf2, 0x55, 0xe0, 0x8e, 0x63, 0x0a, 0x18, 0x04,
	0x63, 0x8b, 0x4f, 0xb3, 0x48, 0x42, 0x5c, 0x4c, 0x24, 0xaa, 0x46, 0x22, 0x67, 0xb1, 0xaf, 0xa0,
	0x49, 0xc9, 0x84, 0x13, 0x7a, 0x89, 0x01, 0xe8, 0x67, 0xaf, 0x60, 0xdf, 0xa1, 0x99, 0xcb, 0x73,
	0x2d, 0xfa, 0xc2, 0xd5, 0x0a, 0x17, 0xae, 0x9e, 0x5d, 0xb8, 0x0d, 0x80, 0x24, 0x15, 0x71, 0xea,
	0x4a, 0x4f, 0x5c, 0xea, 0xc8, 0xbc, 0x55, 0xbe, 0xf7, 0x19, 0x9f, 0xe2, 0xa2, 0xdb, 0x4b, 0x70,
	0xbd, 0xc0, 0x91, 0xe4, 0xd4, 0xac, 0xad, 0xd2, 0x03, 0x3e, 0x61, 0xe5, 0x97, 0x00, 0xae, 0x7b,
	0x09, 0x3e, 0xa0, 0x5d, 0xa0, 0x1c, 0xcb, 0x95, 0xae, 0x06, 0x0a, 0xba, 0xd2, 0x69, 0x2e, 0xbb,
	0x0b, 0xe0, 0xab, 0x60, 0xa8, 0xd2, 0x58, 0xa4, 0x99, 0x43, 0x9b, 0xe2, 0xd0, 0x73, 0x71, 0x91,
	0x3d, 0x5f, 0x31, 0xcf, 0x27, 0x1c, 0xf6, 0x04, 0x56, 0x86, 0xe1, 0x85, 0x0a, 0x46, 0xc2, 0xf3,
	0xc2, 0x73, 0xe9, 0x12, 0xa6, 0xe6, 0x2e, 0x56, 0xe5, 0x17, 0xbb, 0x03, 0x5e, 0x14, 0x64, 0x02,
	0x56, 0x31, 0x6e, 0x0c, 0x85, 0x73, 0xea, 0xcb, 0xf4, 0x24, 0x74, 0xed, 0x37, 0xe8, 0xcd, 0x3e,
	0x7f, 0x95, 0x73, 0x30, 0x0a, 0x9e, 0x91, 0x02, 0x3e, 0xa3, 0x90, 0xfd, 0x1c, 0x1a, 0xae, 0xf4,
	0xd4, 0x99, 0x8c, 0x2f, 0xed, 0x36, 0x29, 0xdf, 0x7a, 0x05, 0xe5, 0xdb, 0x61, 0x90, 0xca, 0x20,
	0xdd, 0x31, 0x1a, 0xf8, 0x44, 0x57, 0xe6, 0x2f, 0xdf, 0xfc, 0xbd, 0xfa, 0xcb, 0xa7, 0xd0, 0x72,
	0x42, 0x3f, 0x12, 0x81, 0x0a, 0x03, 0xe1, 0xda, 0x8c, 0xf2, 0xd7, 0x6b, 0xe6, 0x02, 0xd3, 0x33,
	0x33, 0xf7, 0x72, 0xf3, 0x77, 0x72, 0x2f, 0xbf, 0x84, 0x95, 0x89, 0x4e, 0xf2, 0xe2, 0xb7, 0x48,
	0xdd, 0x93, 0x57, 0xda, 0x3f, 0x33, 0x9f, 0x7c, 0x79, 0x51, 0x1d, 0xfb, 0x33, 0x68, 0x46, 0x9e,
	0x70, 0xa4, 0x2f, 0x83, 0xd4, 0x5e, 0xa3, 0x8d, 0xfc, 0xe2, 0x15, 0x74, 0xd3, 0xff, 0x87, 0x99,
	0x02, 0x5a, 0x20, 0xd7, 0xc7, 0x86, 0xd0, 0xca, 0x90, 0x20, 0x03, 0xd7, 0x7e, 0x87, 0xd4, 0xff,
	0xf8, 0x35, 0x70, 0xb5, 0x2d, 0x93, 0x84, 0x1c, 0xc6, 0xb3, 0xd0, 0x95, 0x7c, 0x5a, 0x29, 0xfb,
	0xb8, 0xe0, 0x2f, 0xf3, 0x3c, 0x9d, 0x14, 0xcc, 0xba, 0xcb, 0xff, 0x29, 0x41, 0x4d, 0x87, 0x7b,
	0x76, 0x1f, 0xea, 0xb1, 0x5e, 0x96, 0x52, 0xc0, 0x56, 0xf7, 0xf6, 0x64, 0xaa, 0x49, 0x08, 0xf4,
	0x53, 0x9e, 0x89, 0x61, 0x62, 0x70, 0x66, 0x92, 0xc3, 0x26, 0xc7, 0x21, 0x7b, 0xaa, 0x4f, 0xb8,
	0xf2, 0x9a, 0x27, 0xfc, 0x65, 0xb9, 0x5d, 0xd2, 0xa7, 0xfc, 0x30, 0x73, 0x2a, 0xd5, 0xab, 0x9c,
	0x0a, 0xcd, 0x31, 0x8e, 0x65, 0x59, 0xa8, 0xd0, 0xf6, 0xcf, 0xbe, 0xfb, 0xaf, 0x2a, 0x50, 0x39,
	0x7c, 0x76, 0xc8, 0x1e, 0xc3, 0x1b, 0x51, 0xac, 0xce, 0x44, 0x2a, 0xbf, 0x11, 0x63, 0x0a, 0x88,
	0x94, 0x9e, 0xcc, 0xfa, 0x0a, 0xbe, 0x6a, 0xa4, 0x7a, 0x5a, 0x88, 0x6d, 0x83, 0xe5, 0x4a, 0xe1,
	0x25, 0xa6, 0xa2, 0xbb, 0x77, 0x75, 0x9a, 0xd6, 0xd1, 0x21, 0x77, 0x47, 0x0a, 0x8f, 0xeb, 0xb9,
	0x58, 0xb4, 0x4d, 0x99, 0x9c, 0x6f, 0xf9, 0xe1, 0xb3, 0xc3, 0x59, 0x7b, 0xff, 0xad, 0x04, 0x90,
	0x2b, 0x98, 0xcb, 0xd6, 0xa7, 0xb3, 0xd3, 0xf2, 0x95, 0xd9, 0x69, 0x65, 0x49, 0x76, 0x3a, 0x29,
	0xc8, 0xaa, 0xd3, 0x05, 0xd9, 0x1a, 0x34, 0xce, 0x85, 0x1b, 0xfa, 0x58, 0x49, 0x58, 0xf4, 0x60,
	0x42, 0xa3, 0x1d, 0x22, 0x35, 0xf1, 0x05, 0xcb, 0xbc, 0x65, 0xc9, 0x61, 0x6e, 0xfa, 0xec, 0x8b,
	0xfd, 0x6b, 0x05, 0xaa, 0x58, 0xc7, 0x4e, 0x5e, 0x29, 0x4b, 0xff, 0x18, 0x54, 0x03, 0xcc, 0x89,
	0x34, 0xc2, 0x68, 0x8c, 0x49, 0xae, 0x31, 0xc4, 0x94, 0x34, 0xc6, 0x0c, 0x2c, 0x03, 0x27, 0x66,
	0xe3, 0x10, 0x23, 0x44, 0xa2, 0x13, 0x1c, 0x7c, 0xa0, 0xcd, 0x9e, 0xe2, 0x30, 0x1b, 0xea, 0x91,
	0x18, 0x49, 0x87, 0xac, 0xc7, 0x87, 0x19, 0x89, 0xeb, 0xe2, 0xd0, 0x64, 0xff, 0x34, 0x66, 0x9f,
	0xc1, 0x0a, 0x9d, 0xbf, 0x73, 0x19, 0x85, 0x9e, 0x72, 0x2e, 0x17, 0x26, 0x6a, 0xbc, 0x28, 0x83,
	0x46, 0xc5, 0xf2, 0x98, 0x8a, 0xd8, 0x26, 0xc7, 0xa1, 0xce, 0xd1, 0x45, 0xec, 0x9c, 0x50, 0xd8,
	0x6b, 0x72, 0x43, 0xb1, 0x1f, 0x41, 0x33, 0x1a, 0x0f, 0x3d, 0x95, 0x9c, 0xc8, 0x98, 0xa2, 0xdd,
	0xe2, 0x62, 0xb0, 0x73, 0x98, 0x09, 0xf1, 0x5c, 0x9e, 0x3d, 0x82, 0xba, 0xa3, 0x63, 0x82, 0xc9,
	0xf0, 0xdf, 0x59, 0x34, 0xd5, 0x84, 0x0d, 0x9e, 0xc9, 0xe2, 0xa9, 0x9e, 0xca, 0xcb, 0xf3, 0x30,
	0x76, 0x75, 0x0d, 0xdc, 0xe4, 0x13, 0x1a, 0xed, 0xf4, 0xc3, 0xa1, 0xf2, 0xa4, 0x2e, 0x74, 0xb9,
	0xa1, 0xd8, 0x47, 0x85, 0xd3, 0xcd, 0xbb, 0x0c, 0x78, 0x7e, 0xb3, 0xe7, 0xfa, 0x5f, 0x15, 0xa8,
	0xf4, 0xa2, 0x88, 0xb1, 0xfc, 0x58, 0xb7, 0xca, 0xf7, 0x1e, 0xd0, 0xd1, 0xde, 0x9e, 0x3e, 0x5a,
	0xe2, 0xfe, 0xff, 0x1d, 0xaf, 0xf1, 0x5b, 0xf5, 0xdc, 0x6f, 0xad, 0x41, 0x6d, 0x38, 0x0e, 0x5c,
	0x4f, 0xa7, 0xdf, 0xda, 0x1e, 0xc3, 0x99, 0x3f, 0xf8, 0xe6, 0x35, 0x0e, 0xfe, 0x7d, 0x44, 0x90,
	0x72, 0x17, 0xb6, 0x2f, 0x38, 0x3d, 0x2a, 0x9e, 0x78, 0xeb, 0xf5, 0x4f, 0xfc, 0xc6, 0x6b, 0x9e,
	0xf8, 0xca, 0xcc, 0x89, 0xaf, 0x41, 0x23, 0x49, 0xc3, 0x58, 0x8e, 0x63, 0x2f, 0x43, 0x43, 0x46,
	0x2f, 0xf5, 0x52, 0xbd, 0x28, 0x9a, 0xf3, 0x52, 0x35, 0xa8, 0x9b, 0x75, 0xe7, 0xee, 0xb3, 0x0d,
	0x75, 0x19, 0xa9, 0x24, 0x74, 0xa5, 0x29, 0xf9, 0x32, 0x92, 0x0a, 0x6e, 0x95, 0x7a, 0xd2, 0x9c,
	0xba, 0x26, 0xf4, 0x65, 0x89, 0x95, 0x4c, 0x4c, 0xf5, 0x6f, 0x28, 0x73, 0x89, 0x92, 0x30, 0x30,
	0xa5, 0xbe, 0xa1, 0xf0, 0x60, 0xd1, 0xfa, 0x9a, 0x3e, 0x58, 0x34, 0xdc, 0xc0, 0xa6, 0x9e, 0xc3,
	0x86, 0xc3, 0x0d, 0x6a, 0x31, 0xbc, 0x18, 0x0b, 0x0f, 0x6b, 0x00, 0x7d, 0x8d, 0x3b, 0xcb, 0x63,
	0x95, 0x79, 0x19, 0x1d, 0x3f, 0xbf, 0xd2, 0xb3, 0x78, 0x41, 0x47, 0x61, 0x5b, 0x9b, 0x33, 0xdb,
	0xfa, 0x21, 0xe6, 0x2b, 0xa4, 0x01, 0x33, 0xfc, 0x60, 0x64, 0x9c, 0x41, 0x91, 0x89, 0x60, 0x1e,
	0x27, 0x32, 0x36, 0x22, 0xda, 0x35, 0x4c, 0x71, 0xd8, 0xb6, 0x39, 0xef, 0x0b, 0x7d, 0xde, 0xab,
	0xdd, 0x1f, 0x5e, 0x6d, 0xf0, 0xb6, 0x9e, 0xc0, 0xb3, 0x99, 0xec, 0x1e, 0x00, 0xe6, 0x89, 0x49,
	0x1a, 0x4b, 0xe1, 0xd3, 0xf9, 0xcf, 0x41, 0x73, 0x4a, 0x80, 0xb9, 0xc0, 0x74, 0x93, 0x2a, 0x96,
	0xa6, 0x05, 0x76, 0xa2, 0x22, 0x93, 0x46, 0x3f, 0xbc, 0x7a, 0x79, 0xd3, 0xe8, 0x9a, 0x9a, 0xcb,
	0x17, 0xe8, 0x63, 0x4f, 0xa0, 0x11, 0xc5, 0xa1, 0x3b, 0x76, 0x64, 0x4c, 0xae, 0xa6, 0xd5, 0x7d,
	0x77, 0xe1, 0x2d, 0x30, 0x32, 0x7c, 0x22, 0x8d, 0x67, 0xeb, 0xc9, 0xc0, 0x6e, 0xeb, 0xbe, 0x84,
	0x27, 0x03, 0xcc, 0xdc, 0x5f, 0x88, 0x91, 0x2f, 0x5d, 0x25, 0xcc, 0x4e, 0xea, 0x4c, 0xf8, 0xfe,
	0xd5, 0xd6, 0x7e, 0xd5, 0x7b, 0xfa, 0x0c, 0xe7, 0x71, 0x9a, 0xb7, 0x55, 0xcf, 0x32, 0xe0, 0x19,
	0x85, 0xb8, 0x87, 0xd2, 0x1f, 0x4a, 0x97, 0x2a, 0x68, 0x9b, 0x2d, 0xdc, 0xc3, 0x5c, 0x00, 0x91,
	0xe1, 0x89, 0x60, 0x34, 0xc6, 0x68, 0x72, 0x53, 0x23, 0x23, 0xa3, 0xd9, 0xbd, 0xc2, 0xa5, 0x9a,
	0x4a, 0x71, 0xb4, 0x49, 0xb3, 0x17, 0xeb, 0x2f, 0xeb, 0x50, 0xd3, 0x2d, 0x59, 0xf6, 0x1e, 0x54,
	0xdc, 0x20, 0x5d, 0x9c, 0xa5, 0xe0, 0x13, 0xbc, 0x78, 0x63, 0x61, 0xc2, 0x66, 0x79, 0x2c, 0xd8,
	0x5b, 0x50, 0x56, 0x91, 0x89, 0xf9, 0xf5, 0xfb, 0x1d, 0xfa, 0xc7, 0xcb, 0x2a, 0xc2, 0x8b, 0x3d,
	0x92, 0xe1, 0xcb, 0x7a, 0xc6, 0x4f, 0x65, 0xc8, 0x51, 0x06, 0x2f, 0xaf, 0xab, 0xdc, 0xe4, 0x44,
	0x3c, 0x30, 0xb7, 0x2e, 0x23, 0xc9, 0x67, 0x2b, 0xd7, 0x77, 0x1f, 0x99, 0x9b, 0x67, 0x28, 0x7c,
	0x79, 0x37, 0x32, 0x53, 0xb4, 0xb3, 0x9d, 0xd0, 0xa4, 0x2d, 0xd2, 0x93, 0x1a, 0x46, 0x9b, 0x26,
	0x31, 0xf8, 0xaa, 0xe8, 0xec, 0xb1, 0xb9, 0x48, 0x34, 0x66, 0xef, 0x42, 0xdd, 0x11, 0x71, 0xac,
	0xa8, 0x5d, 0x96, 0x39, 0xe8, 0x8c, 0x55, 0xd8, 0xe4, 0xd6, 0xcc, 0x26, 0xdf, 0x86, 0xaa, 0x2f,
	0x4e, 0x75, 0x01, 0x69, 0xe2, 0x0c, 0xd2, 0xcc, 0x06, 0xcb, 0x0f, 0x5d, 0xe9, 0x69, 0x37, 0x48,
	0x0f, 0x34, 0x03, 0xa3, 0x55, 0x68, 0xe2, 0xa1, 0x8e, 0x56, 0x61, 0xc2, 0x6e, 0x41, 0x25, 0x4c,
	0xce, 0x08, 0x9f, 0x9a, 0x89, 0x24, 0xdb, 0x80, 0xf2, 0xb7, 0x09, 0xe1, 0x6f, 0x71, 0x5d, 0x59,
	0xfe, 0x36, 0x61, 0xa7, 0xb0, 0xea, 0x84, 0x41, 0xa0, 0xc3, 0x12, 0xd5, 0x2b, 0x57, 0x16, 0x67,
	0xfa, 0x90, 0x11, 0x06, 0x66, 0x1a, 0x56, 0x11, 0x5b, 0x6c, 0xfb, 0xa0, 0xdf, 0xdf, 0xdd, 0x2e,
	0x94, 0x67, 0x33, 0xaa, 0xd9, 0x11, 0x80, 0x6e, 0xd6, 0xd3, 0x42, 0x1a, 0x9c, 0x1f, 0x5f, 0xb9,
	0x90, 0xfe, 0x43, 0x8b, 0x4c, 0x60, 0x3f, 0xa5, 0x07, 0xb7, 0xf7, 0xd8, 0x13, 0xc9, 0x09, 0xc6,
	0x4c, 0x83, 0xe1, 0x8c, 0xa6, 0x3b, 0xe8, 0xa7, 0xf6, 0x2d, 0xca, 0x11, 0x70, 0x88, 0x9c, 0x93,
	0xf3, 0x33, 0xfb, 0x7b, 0xda, 0x07, 0x9f, 0x9c, 0x9f, 0xe9, 0xfe, 0xc3, 0xed, 0x42, 0xff, 0xe1,
	0xad, 0xac, 0xff, 0xd0, 0x86, 0x4a, 0x14, 0x29, 0xdb, 0xd6, 0x77, 0x38, 0x8a, 0x14, 0x85, 0xed,
	0x0b, 0x6a, 0x86, 0xd8, 0x6f, 0x63, 0x16, 0xcb, 0x33, 0x12, 0x65, 0xd5, 0xb1, 0xa0, 0x9a, 0xac,
	0xc9, 0x71, 0x88, 0xb2, 0xbe, 0x70, 0x08, 0x5f, 0xef, 0x68, 0x10, 0x19, 0x92, 0xd2, 0x17, 0xe1,
	0x20, 0xba, 0xde, 0xd5, 0x90, 0xd4, 0x14, 0xf1, 0x1d, 0xc7, 0x0f, 0x1c, 0xfb, 0xae, 0xe1, 0x13,
	0xb5, 0xb4, 0x72, 0xd0, 0x7b, 0x33, 0x7b, 0x15, 0xff, 0xb6, 0x0c, 0xd5, 0xe7, 0x89, 0x8c, 0xe7,
	0x02, 0xdc, 0x1a, 0x34, 0x86, 0xe3, 0x4b, 0x19, 0x8f, 0x27, 0x6d, 0xf8, 0x09, 0x8d, 0xe6, 0x5f,
	0x86, 0x43, 0xd3, 0x15, 0xc2, 0x21, 0x1a, 0x33, 0x92, 0x81, 0x3b, 0x69, 0x6e, 0x1b, 0xaa, 0x10,
	0x4e, 0xac, 0x99, 0x70, 0x72, 0x17, 0xc0, 0x19, 0x27, 0x69, 0xe8, 0xbb, 0x22, 0x15, 0xe6, 0xbe,
	0x4d, 0x71, 0xb2, 0x0b, 0x5d, 0xbf, 0xc6, 0x85, 0xfe, 0x04, 0xaa, 0xa4, 0xa4, 0x41, 0xe5, 0xcb,
	0xc2, 0x0f, 0x3a, 0x3b, 0x22, 0x15, 0x9c, 0xa4, 0x96, 0x26, 0x7e, 0xb8, 0x0f, 0xb3, 0xfb, 0xf3,
	0x57, 0x25, 0x68, 0x4e, 0xd2, 0x96, 0x6b, 0x65, 0xf5, 0x26, 0x4e, 0x57, 0xf2, 0x38, 0x9d, 0x27,
	0x82, 0xd5, 0x42, 0x22, 0xf8, 0x69, 0xc1, 0x8e, 0x3c, 0x56, 0x4c, 0xd6, 0x9b, 0xf3, 0x9b, 0x25,
	0x68, 0x64, 0xd1, 0xe3, 0xf7, 0x6c, 0x4b, 0xa7, 0x60, 0x4b, 0x9e, 0x82, 0x65, 0xcb, 0xcd, 0x9a,
	0xf2, 0xeb, 0x32, 0x54, 0x9e, 0x4a, 0x42, 0xb2, 0x27, 0xb4, 0xff, 0x2e, 0x71, 0x1c, 0x12, 0x27,
	0x0c, 0x74, 0xdd, 0xc6, 0x71, 0x88, 0xd8, 0x76, 0xc2, 0x71, 0x90, 0xc6, 0x97, 0x26, 0x27, 0xca,
	0x48, 0xb4, 0x26, 0x96, 0xa3, 0xac, 0x7f, 0xd8, 0xe4, 0x86, 0xc2, 0x4c, 0x43, 0x8f, 0x8e, 0x55,
	0x94, 0x3c, 0xb8, 0xff, 0xd0, 0x60, 0xa7, 0xc8, 0xa4, 0xb6, 0xa8, 0x4c, 0xe3, 0xd0, 0x60, 0x47,
	0x13, 0xb8, 0x0f, 0x0e, 0x66, 0x43, 0xa6, 0xe2, 0xc1, 0x31, 0xda, 0xf4, 0xe7, 0x2a, 0x32, 0xee,
	0x19, 0x87, 0xec, 0x8f, 0xa0, 0x4a, 0x9e, 0x45, 0x67, 0xc0, 0x1f, 0x2d, 0xf7, 0x2c, 0x4f, 0x65,
	0xd8, 0xd9, 0x0f, 0x1d, 0x91, 0x79, 0x2f, 0x4e, 0xf3, 0xd8, 0xbb, 0xd0, 0x1c, 0xa7, 0x4e, 0x78,
	0x7c, 0x9c, 0xc8, 0x94, 0x1c, 0xb9, 0xc5, 0x73, 0xc6, 0xd2, 0x24, 0xf3, 0xe9, 0x7c, 0xdb, 0xe2,
	0x57, 0x65, 0xa8, 0x22, 0x36, 0xaf, 0x75, 0x9e, 0x5b, 0x50, 0x4f, 0xe4, 0x88, 0xfa, 0x39, 0x15,
	0x82, 0xfa, 0xfa, 0x32, 0xa8, 0x77, 0x06, 0x5a, 0x8e, 0x67, 0x13, 0x96, 0xa2, 0x1e, 0xa5, 0x67,
	0x8d, 0x8a, 0xa1, 0x6e, 0xe6, 0x5f, 0xcb, 0xac, 0x5b, 0x60, 0x9d, 0x09, 0x6f, 0x3c, 0x49, 0x79,
	0x89, 0x58, 0x9a, 0x14, 0x18, 0xcd, 0xb3, 0x6b, 0x4a, 0x68, 0x4d, 0x7d, 0xa2, 0x64, 0x1f, 0x80,
	0xe5, 0x84, 0x51, 0x24, 0x16, 0xa7, 0x06, 0xfa, 0x19, 0x7b, 0x50, 0x58, 0x22, 0xff, 0x10, 0x3d,
	0xa5, 0x68, 0x66, 0x99, 0x8d, 0xff, 0xad, 0x41, 0x8b, 0xf6, 0x2a, 0x89, 0xc2, 0x20, 0x99, 0x2f,
	0xd4, 0x1f, 0xe3, 0x16, 0x8b, 0x74, 0x48, 0x6e, 0xaf, 0x32, 0x9f, 0xc3, 0xe9, 0x69, 0x9d, 0x81,
	0x14, 0x29, 0xd2, 0x99, 0x30, 0xee, 0xc1, 0x50, 0xb9, 0x93, 0x4f, 0x3e, 0x9a, 0x60, 0xdf, 0xd3,
	0x5f, 0x74, 0xab, 0x79, 0x8b, 0x82, 0x3e, 0xeb, 0x16, 0x5d, 0x9f, 0x35, 0xe7, 0xfa, 0x9e, 0x40,
	0x25, 0x18, 0xc6, 0xe6, 0xdb, 0xde, 0x0f, 0x16, 0x81, 0xd3, 0x98, 0xd1, 0x0f, 0x89, 0xc2, 0x92,
	0x81, 0xe3, 0x94, 0xa5, 0x3b, 0x32, 0x35, 0x69, 0x76, 0xe3, 0x7f, 0x5b, 0xc5, 0xd3, 0xa6, 0xd7,
	0x61, 0x5d, 0xa8, 0x0c, 0x69, 0x3b, 0x16, 0x80, 0xab, 0xf8, 0xe6, 0xc4, 0x43, 0x61, 0x44, 0x04,
	0xb5, 0x59, 0x0c, 0x22, 0xa8, 0xcb, 0xf2, 0x01, 0x58, 0xa3, 0x38, 0x1c, 0xeb, 0x44, 0x6d, 0xfe,
	0xf4, 0xe8, 0xd9, 0x4b, 0x00, 0x42, 0x2b, 0xcc, 0xda, 0xf9, 0x4f, 0x15, 0xa8, 0xa0, 0x8d, 0xb3,
	0xdd, 0xa2, 0x5b, 0x60, 0x29, 0x3f, 0xa2, 0xf3, 0x42, 0x96, 0x26, 0x90, 0x1b, 0xc5, 0xca, 0x41,
	0x4c, 0x96, 0x37, 0x4b, 0x5c, 0x13, 0x68, 0xab, 0xc0, 0x43, 0xd2, 0xee, 0x86, 0xc6, 0x84, 0x68,
	0xac, 0xb5, 0x2c, 0x83, 0x68, 0x53, 0x6c, 0x09, 0xd7, 0xcf, 0xca, 0x2f, 0xe1, 0xfa, 0xe8, 0xc4,
	0xb2, 0xb6, 0x91, 0x2e, 0xc1, 0x32, 0x92, 0xb2, 0x3c, 0x9c, 0xdf, 0x30, 0x59, 0x5e, 0x56, 0xac,
	0x29, 0xd7, 0x24, 0x7e, 0x38, 0x24, 0xb7, 0x14, 0x9b, 0x32, 0x1a, 0xdd, 0x52, 0xac, 0x5c, 0xd6,
	0x81, 0x2a, 0x75, 0x06, 0x5b, 0x57, 0x7e, 0x6e, 0x20, 0x39, 0x72, 0xde, 0x52, 0x78, 0xca, 0xd5,
	0x39, 0x20, 0x37, 0x94, 0x4e, 0x4b, 0x56, 0x0a, 0x69, 0xc9, 0x6a, 0x96, 0x96, 0xdc, 0x9e, 0xf4,
	0x03, 0xde, 0xd0, 0x73, 0x4c, 0x2f, 0xc0, 0x84, 0x86, 0x76, 0x1e, 0x1a, 0x1e, 0x03, 0x08, 0xd7,
	0xff, 0xc6, 0x7c, 0x5f, 0xed, 0xce, 0xb8, 0x89, 0xac, 0x71, 0xaa, 0x51, 0xc0, 0x9b, 0xc2, 0xf5,
	0x4d, 0xb7, 0x75, 0x99, 0xb3, 0x9b, 0x3f, 0xc2, 0x8d, 0xbf, 0x6f, 0xc1, 0x4a, 0xa1, 0x03, 0x9b,
	0x35, 0x30, 0x4a, 0x79, 0x03, 0x63, 0x00, 0x35, 0x4f, 0x5c, 0x86, 0xe3, 0xd4, 0x7c, 0xd3, 0xfa,
	0xd1, 0xb5, 0x7a, 0xaf, 0x05, 0xad, 0x9d, 0x7d, 0x52, 0xb0, 0xe7, 0x72, 0xa3, 0x0a, 0x95, 0x0a,
	0x77, 0x1c, 0xa8, 0xd4, 0x00, 0xf2, 0x75, 0x94, 0xf6, 0xdc, 0xe7, 0x81, 0x22, 0xa5, 0x5a, 0x15,
	0xbb, 0x03, 0x8d, 0xc8, 0x73, 0xfc, 0xd4, 0x09, 0x52, 0xfd, 0xfd, 0x8b, 0xbe, 0x26, 0x65, 0x2c,
	0x76, 0x13, 0x2a, 0x89, 0x7c, 0x41, 0xb0, 0xa2, 0x6f, 0x42, 0x48, 0xb1, 0x87, 0x50, 0x13, 0x49,
	0x22, 0xd3, 0x84, 0x3a, 0x39, 0xd3, 0xde, 0x65, 0x66, 0x31, 0x14, 0xe2, 0x46, 0x96, 0x1d, 0xe5,
	0x35, 0x73, 0x9d, 0xec, 0xdf, 0x7a, 0x0d, 0xfb, 0xe7, 0x8a, 0x68, 0x45, 0x09, 0x3d, 0x0e, 0x93,
	0xb1, 0xfe, 0x8c, 0xac, 0x3b, 0x08, 0xbd, 0xd7, 0x57, 0x3e, 0xd0, 0x8a, 0xf8, 0x8c, 0x62, 0xf6,
	0x4b, 0x68, 0xd2, 0xbe, 0x4c, 0xc5, 0xdc, 0x1f, 0xbf, 0xc6, 0x2a, 0x73, 0x5f, 0x23, 0x8c, 0xca,
	0xb5, 0x5f, 0xd7, 0xc0, 0xa2, 0x2d, 0x9b, 0xf2, 0x0e, 0x16, 0x79, 0x87, 0xf7, 0xa1, 0x11, 0xcb,
	0x17, 0x63, 0x15, 0x4b, 0x9d, 0xc7, 0x4e, 0x7e, 0xe8, 0x32, 0x61, 0xb3, 0x27, 0xd3, 0x1d, 0x9b,
	0xe9, 0x1f, 0x29, 0x2c, 0x38, 0x92, 0xce, 0x11, 0x4a, 0x66, 0x5d, 0x9d, 0x87, 0x50, 0x51, 0xfe,
	0xc8, 0xd4, 0x9c, 0x2f, 0x9f, 0xb7, 0xe7, 0x8b, 0x91, 0xe4, 0x28, 0x9e, 0xff, 0x9a, 0xc4, 0x7a,
	0xf5, 0x5f, 0x93, 0x3c, 0x32, 0x99, 0xae, 0xfe, 0xe9, 0xd2, 0xfb, 0x2f, 0x5d, 0x32, 0x4f, 0x79,
	0xd7, 0xd6, 0xc1, 0x22, 0xc3, 0xb3, 0x4e, 0x83, 0xde, 0x1f, 0x1c, 0x66, 0x3f, 0xa0, 0xf9, 0xf7,
	0x12, 0x58, 0x64, 0x23, 0xdb, 0x35, 0xa9, 0x91, 0x0e, 0xbc, 0x0f, 0xae, 0x7e, 0x2b, 0xfd, 0x3f,
	0x31, 0xa6, 0x32, 0x24, 0x72, 0x4a, 0xe5, 0x82, 0x53, 0xaa, 0x64, 0x4e, 0x29, 0xfb, 0x60, 0x5e,
	0x5d, 0xf0, 0xc1, 0xdc, 0x9a, 0xfa, 0x60, 0x3e, 0xf9, 0xf0, 0x5d, 0x9b, 0xfa, 0xf0, 0xbd, 0xd1,
	0x81, 0xd5, 0xe2, 0x8a, 0xac, 0x01, 0xd5, 0xbd, 0xed, 0x83, 0x7e, 0xbb, 0x84, 0xa3, 0xfd, 0x83,
	0xa7, 0x07, 0xed, 0x32, 0x8e, 0x9e, 0xf5, 0xf6, 0xfa, 0xed, 0x4a, 0xf6, 0x86, 0x7f, 0x93, 0x65,
	0x5a, 0xdb, 0x85, 0x17, 0xfc, 0xf4, 0xca, 0x3d, 0xa4, 0xff, 0x66, 0x5f, 0xcf, 0x6c, 0x64, 0x79,
	0xd2, 0xb2, 0xd9, 0xf8, 0xc7, 0x12, 0xac, 0x14, 0x24, 0xd9, 0x0a, 0x34, 0x07, 0x87, 0x07, 0xfd,
	0xc1, 0x01, 0xdf, 0xdd, 0xd1, 0xb6, 0xed, 0xec, 0x0e, 0xb6, 0xdb, 0x65, 0x06, 0x50, 0xe3, 0xbd,
	0xa3, 0xbd, 0xfe, 0xd3, 0x76, 0x85, 0x35, 0xc1, 0xda, 0xdf, 0xfb, 0xd9, 0xee, 0xa0, 0x5d, 0x45,
	0xf9, 0x9d, 0x83, 0xaf, 0xfb, 0xfb, 0x07, 0xbd, 0x9d, 0x41, 0xdb, 0xc2, 0x27, 0x87, 0x7c, 0x6f,
	0x7b, 0xb7, 0x5d, 0x23, 0x4d, 0xbd, 0xfd, 0x5d, 0x4d, 0xd6, 0xe9, 0xc9, 0x4f, 0x0f, 0xfa, 0xbb,
	0xed, 0x06, 0x6b, 0x41, 0xbd, 0xb7, 0xb3, 0xc3, 0x77, 0x07, 0x83, 0x76, 0x13, 0xf9, 0xb8, 0x42,
	0xb7, 0x0d, 0x6c, 0x15, 0x60, 0x67, 0x6f, 0x70, 0xb8, 0xdf, 0xfb, 0xc5, 0x73, 0xbe, 0xdf, 0x6e,
	0xa1, 0xdc, 0xf6, 0x51, 0xef, 0x68, 0xf7, 0x4f, 0x8e, 0xda, 0x37, 0x18, 0x80, 0x35, 0x38, 0x3a,
	0xe0, 0xbb, 0xed, 0xff, 0xce, 0x76, 0xa7, 0xf8, 0x67, 0xe3, 0x37, 0x35, 0x58, 0x2d, 0x7a, 0xfc,
	0x05, 0x9e, 0xfa, 0xd1, 0xc4, 0x97, 0xe9, 0x4c, 0xe9, 0xce, 0x92, 0x60, 0x31, 0xe3, 0xcc, 0xee,
	0x43, 0xd5, 0x53, 0xc1, 0x29, 0x05, 0xe6, 0x45, 0x0e, 0xd0, 0x4c, 0xda, 0x57, 0xc1, 0x29, 0x27,
	0x49, 0xb6, 0x0e, 0x2d, 0xe5, 0x47, 0x69, 0x2c, 0x9c, 0x53, 0x19, 0x27, 0xa6, 0x73, 0x3e, 0xcd,
	0xc2, 0x74, 0xfc, 0xdb, 0xc4, 0x50, 0x26, 0x90, 0xe7, 0x8c, 0x35, 0x01, 0x55, 0xd4, 0x96, 0x35,
	0x55, 0x4b, 0x79, 0x53, 0xf5, 0x43, 0x58, 0x71, 0x3c, 0xe5, 0x9c, 0x4e, 0x74, 0x97, 0x49, 0x77,
	0x91, 0x49, 0x6d, 0x03, 0xe1, 0x79, 0x43, 0xe1, 0x9c, 0x9a, 0xf4, 0x6e, 0x42, 0x67, 0xe0, 0xfa,
	0xbb, 0xea, 0xef, 0xe0, 0x80, 0x3e, 0x2f, 0x3a, 0xa0, 0x0f, 0x5e, 0xba, 0x8f, 0x45, 0x0f, 0xf4,
	0x68, 0xda, 0x03, 0x5d, 0x31, 0x71, 0xca, 0x05, 0x7d, 0x5e, 0x74, 0x41, 0x57, 0x4c, 0x2c, 0x78,
	0xa0, 0xc7, 0x05, 0x0f, 0xb4, 0xf1, 0xf2, 0x99, 0x53, 0x55, 0x77, 0x76, 0xec, 0xb3, 0xd5, 0xee,
	0xd2, 0x63, 0x5f, 0xdb, 0xc8, 0x9c, 0x16, 0x83, 0x2a, 0xc5, 0x3e, 0x9d, 0xf3, 0xd1, 0x38, 0xdb,
	0xf7, 0x3f, 0xcc, 0xbc, 0xd6, 0xfc, 0xd9, 0xbe, 0xc4, 0x01, 0x65, 0xb3, 0x3f, 0x37, 0x1e, 0xe1,
	0x16, 0x58, 0x9e, 0x18, 0xca, 0x6c, 0xba, 0x26, 0xf2, 0xb2, 0xc6, 0x24, 0x96, 0x44, 0x64, 0x53,
	0x37, 0xb3, 0x1f, 0xe7, 0xd8, 0x50, 0x3f, 0x13, 0x49, 0x9a, 0x8a, 0x91, 0xf9, 0x79, 0x4e, 0x46,
	0x2e, 0xbc, 0x59, 0x5f, 0xbe, 0xff, 0xcf, 0xdf, 0xdd, 0x2d, 0xfd, 0xcb, 0x77, 0x77, 0x4b, 0xff,
	0xf1, 0xdd, 0xdd, 0x12, 0xdc, 0x74, 0x42, 0xbf, 0x63, 0x7e, 0x91, 0x9b, 0xed, 0xc8, 0xff, 0x05,
	0x00, 0x00, 0xff, 0xff, 0x83, 0x04, 0xb0, 0x88, 0xec, 0x2b, 0x00, 0x00,
}
